<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>NostrPostr</title>

    <!-- Favicon for most browsers -->
    <link rel="icon" href="/img/favicon_io/favicon.ico" type="image/x-icon">
    
    <!-- PNG icons for better resolution -->
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png">
    
    <!-- Apple Touch Icon (for iOS) -->
    <link rel="apple-touch-icon" href="/img/favicon_io/apple-touch-icon.png">
    
    <!-- Web Manifest (for PWAs) -->
    <link rel="manifest" href="/img/favicon_io/site.webmanifest">
    <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
    <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/easyqrcodejs@4.6.1/dist/easy.qrcode.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="backgroundImages.js"></script>
    <script src="background.js"></script>
    <script src="font.js"></script>
    <script src="fontList.js"></script>  
    <script src="crypto-js.min.js"></script>                                                                                                                   
    <script src="dec.js"></script>                                                                                                                   
    <script src="bech32.js"></script>                                                                                                                   
    <script src="note1.js"></script>
    <!-- <script src="footer.js"></script> // IS AT THE BOTTOM-->
</head>

<body>
    <div id="dim-overlay" class="dim-overlay"></div>
    <div>
        <img id="avatarIcon" class="avatar-icon" src="" alt="Avatar" title="Change ID">
        <p id="nostrNameDisplay" class="nostr-name"></p>  <!-- Display for nostr_name -->
        <h1 id="mainTitle">Freedom to Speak</h1>
        <h4 id="subTitle">No Names. Just Unfiltered Truth.</h4>
        <div id="paragraphContainer">
            <p id="customParagraph" style="margin-top: 1rem;" data-full-content=""></p>
            <a href="#" id="readMoreLink" style="display: none;">Read more</a>
        </div>
    </div>

    <div id="warningMessage" style="display: none; color: red; text-align: center; font-size: 2rem;  margin: 20px; margin-bottom: 3%;">
        <strong>Posting is only available on custom websites. If you'd like to create one, use </strong>
        <a href="urlmkr.html" style="color: rgb(30, 255, 0);  text-decoration: underline;">URLmkr</a>.
    </div>
    <!-- <textarea id="userMessage" maxlength="280" oninput="adjustHeight(this)"></textarea> -->
    <div class="editor-container">
        <textarea id="userMessage" maxlength="280" oninput="updateMarkdown()" placeholder="Type your message..."></textarea>
        <div id="markdownPreview" class="overlay markdown-preview"></div>
    </div>
    <div id="charCount">0/280</div>
    <button id="sendMessageBtn" disabled>send
        <img src="https://user-images.githubusercontent.com/99301796/219719339-5eff628c-3470-4cc3-81eb-404f8902de9f.gif" id="animatedImg"/>
    </button>

    <p id="statusMessage"></p>

    <p id="relayWarning" style="color:red; display:none; background-color: rgba(0, 0, 0, 0.672);">
        Possible connection error! <br>
        None of the relays are available please try later. <br>
        <span style="color: rgb(239, 219, 0);">Would you like to try the default relays listed bellow?</span> <br>
        <span style="color: #00ff5599;">relay.nostr.band, relay.damus.io,
        njump.me, relay.snort.social and nos.lol?</span> <br>
        
        <button id="useDefaultRelaysBtn">Yes</button>
        <button id="closeRelayWarning">No</button>
    </p>
    <div id="eventDetails"></div>


    
    <footer class="footerDynamic">
        <a href="about.html">About</a> | 
        <a href="FAQ.html">FAQ</a> | 
        <a href="urlmkr.html">URLmkr</a> | 
        <button id="showHistoryBtn"  title="a History data of all the posted notes from this device">Show History</button>
    </footer>

<!-- Modal for viewing notes -->
<div id="notesModal">
    <div id="notesModalContent">
        <div id="notesHeader">
            <button id="downloadDataBtn">Download Data</button>
        </div>
        <div id="dynamicContent"></div> <!-- Dynamic content (notes) goes here -->
        <div class="panic-container">
            <button id="wipeStorageBtn">
                ‚ùå Delete All Data (Panic Btn) ‚ùå
            </button>
        </div>
    </div>
</div>

<!-- enter password modal -->
<div id="passwordModal" class="active">
    <div>
        <h3>Enter Password</h3>
        <p id="passwordHint" style="display: none; text-align: center; margin-top: 10px; color: #555;">Password hint:</p>
        <input type="password" id="passwordInput" placeholder="Password">
        <button id="submitPassword">Submit</button>

        <p id="passwordError" style="color: red;">Invalid password. Please try again.</p>
    </div>
</div>

<!-- saved passwords notifications -->
<div id="passwordNotification">
    <p>
        You've already unlocked this page.
        To lock it again, press the button below.
    </p>
    <button id="clearHashes">Clear Stored Hashes</button>
</div>


<!-- modal for viewing media items -->
<div class="fullscreen-modal">
    <span class="close-btn">&times;</span>
    <div class="modal-content"></div>
</div>

<!-- QR Code Modal -->
<div id="qr-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center;">
    <div style="z-index: 10001; background: #fff; padding: 20px; border-radius: 8px; text-align: center;">
        <div id="qr-code"></div>
        <div id="qr-title">Scan with Nostr app</div>
        <button id="close_qr_button" class="copy-button" style="background: #ff4d4d;">Close</button>
    </div>
</div>

<script>

// Function to load JSON files
async function loadJson(file) {
    const response = await fetch(file);
    return response.json();
}

const avatarStyles = {
    1: "croodles",
    2: "adventurer-neutral",
    3: "avataaars",
    4: "avataaars-neutral",
    5: "big-ears",
    6: "big-ears-neutral",
    7: "big-smile",
    8: "bottts",
    9: "bottts-neutral",
    10: "adventurer",
    11: "croodles-neutral",
    12: "fun-emoji",
    13: "icons",
    14: "identicon",
    15: "rings",
    16: "lorelei",
    17: "lorelei-neutral",
    18: "micah",
    19: "miniavs",
    20: "notionists",
    21: "notionists-neutral",
    22: "open-peeps",
    23: "personas",
    24: "pixel-art",
    25: "pixel-art-neutral",
    26: "shapes",
    27: "thumbs",
    28: "dylan",
    29: "glass",
    // 30: "initials",
};

// Function to generate DiceBear avatar URL from public key
function getAvatarUrl(pubkey) {
    const storedAvatarUrl = localStorage.getItem("avatar_url");

    // If avatar exists in localStorage, return it
    if (storedAvatarUrl) {
        return storedAvatarUrl;
    }

    // Otherwise, get avatar style from query parameters (for new IDs)
    const { a } = getQueryParams(); 
    const seed = encodeURIComponent(pubkey);

    // Determine avatar style or fallback to croodles
    const avatarStyle = avatarStyles[a] || "croodles";

    // Return generated URL
    return `https://api.dicebear.com/9.x/${avatarStyle}/svg?seed=${seed}`;
}

// Function to update the avatar
function updateAvatar() {
    const avatar = document.getElementById("avatarIcon");

    // Generate URL based on public key and chosen avatar style
    const avatarUrl = pub
        ? getAvatarUrl(pub) + `&cacheBust=${Date.now()}` // Bust cache to force new fetch
        : getAvatarUrl("placeholder");

    avatar.src = avatarUrl;
    console.log("Updated Avatar URL:", avatarUrl);
}

// Function to update the displayed nostr_name under the avatar
function updateNostrNameDisplay() {
    const nostrNameDisplay = document.getElementById("nostrNameDisplay");
    const nostrName = localStorage.getItem("nostr_name");

    if (nostrName) {
        nostrNameDisplay.textContent = nostrName;
    } else {
        // If nostr_name doesn't exist, generate a fallback name
        nostrNameDisplay.textContent = generateRandomFallback();
    }
}

function applyRandomTiltForNostrName() {
    const nostrName = document.getElementById('nostrNameDisplay');
    const randomTilt = Math.floor(Math.random() * 31) - 15;  // Tilt between -30 to 30 degrees
    nostrName.style.transform = `rotate(${randomTilt}deg)`;
}

const randomAvatarStyle = Math.floor(Math.random() * Object.keys(avatarStyles).length) + 1;

function getQueryParams() {
    const params = new URLSearchParams(window.location.search);
    return {
        f: params.has("f") ? params.get("f") : null, // Include font only if present
        t: params.has("t") ? params.get("t") : null, // Include title only if present
        s: params.has("s") ? params.get("s") : null, // Include subtitle only if present
        p: params.get("p") || "",  // Paragraph
        m: params.get("m") || "", // Message
        h: params.get("h") ? params.get("h").split(",").filter(Boolean) : [], // Hashtag
        r: params.get("r") ? params.get("r").split(",") : [], // Relay
        l: parseInt(params.get("l")) || 280, // Length of a message
        b: params.get("b") || "", // Background
        // a: parseInt(params.get("a")) || 1, // Avatar style (defaults to 1)
        a: parseInt(params.get("a")) || randomAvatarStyle, // Avatar style (defaults to random)
        ln: params.get("ln") || ""  // Lightning address (reverse format)
    };
}

async function setDynamicContent() {
    const urlParams = new URLSearchParams(window.location.search);  // Define urlParams here
    const { t, s, p, m, h, r, l, b } = getQueryParams();
    const maxLength = 300;  // Maximum characters before truncating

    // Handle the title and subtitle
    document.getElementById("mainTitle").textContent = t || "Freedom to Speak"; // Show only if `t` exists
    document.getElementById("subTitle").textContent = s || "No Names. Just Unfiltered Truth"; // Show only if `s` exists

    const paragraph = document.getElementById("customParagraph");
    const readMoreLink = document.getElementById("readMoreLink");

    if (p) {
        // Replace media links first
        let processedContent = replaceMediaLinks(p); // Replace media links

        // Store the processed content for truncation and expansion
        paragraph.setAttribute('data-full-content', processedContent);
        // console.log("Content before truncation on page load:", paragraph.innerHTML);
        paragraph.setAttribute('data-npub-processed', 'true'); // Mark as processed

        // // Truncate content for initial view
        // truncateParagraph(paragraph);

        // Replace `nostr:npub` strings in the content
        processedContent = await replaceNpubStrings(processedContent); // Replace `nostr:npub`

        // Truncate content for initial view
        truncateParagraph(paragraph);

        // Show the "Read More" link
        readMoreLink.style.display = "inline";

        // Fetch note1 events in the processed content
        fetchNote1Strings(processedContent, r);

        readMoreLink.onclick = async (e) => {
            e.preventDefault();
            const expanded = paragraph.getAttribute('data-expanded') === "true";
            
            if (expanded) {
                // Collapse content
                truncateParagraph(paragraph);
                readMoreLink.textContent = "Read more";
                paragraph.setAttribute('data-expanded', "false");

            } else {
               // Expand content
                let expandedContent = paragraph.getAttribute('data-full-content');
                expandedContent = replaceMediaLinks(expandedContent); // Reapply media links to expanded content
                expandedContent = await replaceNpubStrings(expandedContent);

                // Skip reprocessing if already processed
                // Ensure `replaceNpubStrings` is applied only to raw content
                if (!paragraph.getAttribute("data-npub-processed")) {
                    expandedContent = replaceMediaLinks(expandedContent);
                    expandedContent = await replaceNpubStrings(expandedContent);
                    paragraph.setAttribute("data-npub-processed", "true");
                }
                
                paragraph.innerHTML = expandedContent;
                readMoreLink.textContent = "Close";
                paragraph.setAttribute('data-expanded', "true");

                // Fetch embedded `note1` events in the expanded content
                fetchNote1Strings(paragraph.innerHTML, r);

                // Reapply modal listeners
                applyModalListenersToMedia(paragraph);

                markLikedEvents(); // Mark likes on expanded content
            }
        };

        // Reapply modal listeners
        applyModalListenersToMedia(paragraph);

        // Fetch `note1` events in the truncated content
        fetchNote1Strings(paragraph.innerHTML, r); 

        // Mark likes for initially visible events
        markLikedEvents();

    } else {
    // If no `p` parameter is provided, set default content and process random GIF links

    // List of media links
    const mediaLinks = [
        "https://media1.tenor.com/m/rec5dlPBK2cAAAAd/mr-bean-waiting.gif",
        "https://media1.tenor.com/m/4EElxXeHiZwAAAAC/forrest-gump-wave.gif",
        "https://media1.tenor.com/m/g6JYL4ILCFsAAAAd/on-cookies.gif",
        "https://media1.tenor.com/m/g_94qXGDaicAAAAd/counter-travolta.gif",
        "https://media1.tenor.com/m/nO8QxT9B29kAAAAd/wtf-what-the-fuck.gif",
        "https://media1.tenor.com/m/IvyuPtEfzhoAAAAd/matrix.gif",
        "https://media1.tenor.com/m/WMe5rMx9OIcAAAAd/ostrich-m.gif",
        "https://media1.tenor.com/m/zvke6dexeEEAAAAC/anonymous-mask.gif",
        "https://media1.tenor.com/m/hemfK_5WFGcAAAAd/cookie-monster-waiting.gif",
        "https://media1.tenor.com/m/TRhQGkZGzfEAAAAd/bh187-v-for-vendetta.gif",
        "https://media1.tenor.com/m/FSp-pDzKXKsAAAAC/girls-kissing-tired.gif",
        "https://media1.tenor.com/m/f6KifE_p2DAAAAAd/leyendo-hora-de-aventura.gif",
        "https://media1.tenor.com/m/veoNy8bkTLMAAAAd/blink-kid.gif",
    ];


    // Pick a random link from the list
    const randomLink = mediaLinks[Math.floor(Math.random() * mediaLinks.length)];

    // Process the selected link
    let fallbackContent = randomLink;
    fallbackContent = replaceMediaLinks(fallbackContent); // Process fallback content
    
    replaceNpubStrings(expandedContent);
    paragraph.innerHTML = fallbackContent; // Directly set processed content
    readMoreLink.style.display = "none"; // Hide "Read more" if no additional content
    }


    const userMessage = document.getElementById("userMessage");
    userMessage.setAttribute("data-hashtags", h.join(","));
    userMessage.setAttribute("maxlength", l);

    if (m) {
        userMessage.value = m;
        userMessage.disabled = true;
        document.getElementById("sendMessageBtn").disabled = false;
    }

    document.getElementById("charCount").textContent = `0/${l}`;

    if (r.length > 0) {
        setRelays(r);
    } else {
        setRelays([
            "wss://relay.nostr.band",
            "wss://relay.damus.io",
            "wss://njump.me",
            "wss://relay.snort.social",
            "wss://nos.lol",
        ]);
    }

    if (b && backgroundImages[b]) {
        document.body.style.backgroundImage = `url('img/background/${backgroundImages[b]}')`;
        document.body.style.backgroundRepeat = "repeat";
    }

    // if (sendMessageBtn.disabled) {
    // sendMessageBtn.title = "Please use this tool with custom websites and not random posting";
    // }

    if (!urlParams.toString()) {
    sendMessageBtn.title = "Send button disabled. Build s custom website with URLmkr tool for posting.";
    avatarIcon.title = "Avatar disabled. ID change is only allowed on custom websites. Build one with URLmkr";
    }

}

// // helper function scans the paragraph for note1 strings and invokes fetchNote1Event function
// function fetchNote1Strings(content, relays) {
//     const note1Matches = content.match(/note1\w+/g) || [];
//     note1Matches.forEach(note1String => {
//         const { eventId } = decodeNote1(note1String) || {};
//         if (eventId) fetchNote1Event(eventId, relays, note1String);
//     });
// }

// Helper function scans the paragraph for nostr:note1 strings and invokes fetchNote1Event function
function fetchNote1Strings(content, relays) {
    const note1Matches = content.match(/nostr:note1\w+/g) || [];
    note1Matches.forEach(note1String => {
        const { eventId } = decodeNote1(note1String) || {};
        if (eventId) fetchNote1Event(eventId, relays, note1String); // Fetch event for nostr:note1
    });

    // Handle plain note1 strings by showing them as raw text
    const plainNote1Matches = content.match(/\bnote1\w+\b(?!:)/g) || [];
    plainNote1Matches.forEach(note1String => {
        content = content.replace(
            note1String,
            `<span style="color: gray;">${note1String}</span>` // Render plain note1 as gray text
        );
    });

    return content;
}

async function truncateParagraph(paragraph) {
    const maxLength = 300; // Limit for truncation
    const fullContent = paragraph.getAttribute('data-full-content');

    // console.log("Full content for truncation:", fullContent);

    if (!fullContent) return;

    // Temporarily remove note1 placeholders for clean truncation
    const tempContent = fullContent.replace(/<div class="note-box">[\s\S]*?<\/div>/g, '[note1]');
    let truncatedText = tempContent.length > maxLength
        ? `${tempContent.substring(0, maxLength)}...`
        : tempContent;

    // Reinsert note1 placeholders into truncated content
    let displayContent = truncatedText;
    const noteBoxes = [...fullContent.matchAll(/<div class="note-box">[\s\S]*?<\/div>/g)];
    noteBoxes.forEach(noteBox => {
        displayContent = displayContent.replace('[note1]', noteBox[0]);
    });

    // Process media links after truncation
    displayContent = replaceMediaLinks(displayContent);

    // Ensure `replaceNpubStrings` is applied to truncated content
    displayContent = await replaceNpubStrings(displayContent);

    paragraph.innerHTML = displayContent;
    paragraph.setAttribute('data-expanded', "false");
    // console.log("Final truncated content:", paragraph.innerHTML);

    // Fetch `note1` events in the truncated content
    fetchNote1Strings(paragraph.innerHTML, getQueryParams().r);   

    // Reapply modal listeners
    applyModalListenersToMedia(paragraph);
}

function replaceMediaLinks(content) {
    // Match image and video URLs
    const imageRegex = /(https?:\/\/\S+\.(?:png|jpe?g|gif|webp))(?![^<>]*>)/gi;
    const videoRegex = /(https?:\/\/\S+\.(?:mp4|webm|ogg))(?![^<>]*>)/gi;

    let imageIdCounter = 0; // Counter for unique image IDs
    let videoIdCounter = 0; // Counter for unique video IDs

    // Replace image URLs with <img> tags and assign unique IDs
    content = content.replace(imageRegex, (match) => {
        const id = `embedded-image-${imageIdCounter++}`;
        return `<img id="${id}" src="${match}" alt="Embedded Image">`;
    });

    // Replace video URLs with <video> tags and assign unique IDs
    content = content.replace(videoRegex, (match) => {
        const id = `embedded-video-${videoIdCounter++}`;
        return `
            <video id="${id}" controls>
                <source src="${match}" type="video/${match.split('.').pop()}">
                Your browser does not support the video tag.
            </video>
        `;
    });

    return content;
}

// Modal for media content
document.addEventListener("DOMContentLoaded", () => {
    // console.log("DOM fully loaded and parsed.");

    // Select the existing modal elements
    const modal = document.querySelector(".fullscreen-modal");
    const modalContent = modal.querySelector(".modal-content");
    const closeButton = modal.querySelector(".close-btn");

    if (!modal || !modalContent || !closeButton) {
        // console.error("Modal structure is missing in the HTML. Please ensure it exists.");
        return;
    }

    // console.log("Modal structure found. Setting up event listeners.");

    // Function to handle modal interactions
    const setupModal = () => {
        // Close modal on click of close button
        closeButton.addEventListener("click", () => {
            // console.log("Close button clicked. Hiding modal.");
            modal.classList.remove("active");
            modalContent.innerHTML = ""; // Clear modal content
        });

        // Close modal on outside click
        modal.addEventListener("click", (e) => {
            if (e.target === modal) {
                // console.log("Modal background clicked. Hiding modal.");
                modal.classList.remove("active");
                modalContent.innerHTML = ""; // Clear modal content
            }
        });
    };

    // Set up modal close interactions
    setupModal();

    // Apply modal listeners globally on page load
    const paragraph = document.querySelector("#customParagraph");
    if (paragraph) {
        applyModalListenersToMedia(paragraph);
    }

    // Reapply listeners after dynamic content updates
    document.addEventListener("contentUpdated", () => {
        // console.log("Dynamic content updated. Reapplying modal listeners.");
        if (paragraph) {
            applyModalListenersToMedia(paragraph);
        }
    });
});

// Refactored applyModalListenersToMedia function
function applyModalListenersToMedia(container) {
    // console.log("Applying modal listeners for media items in the container.");
    const mediaItems = container.querySelectorAll('img[id^="embedded-image-"], video[id^="embedded-video-"]');

    if (mediaItems.length === 0) {
        // console.warn("No media items found to attach event listeners.");
        return;
    }

    mediaItems.forEach((media) => {
        // Avoid duplicate event listeners
        if (media.dataset.modalListener === "true") return;

        media.addEventListener("click", () => {
            // console.log("Media item clicked:", media);

            const modal = document.querySelector(".fullscreen-modal");
            const modalContent = modal.querySelector(".modal-content");

            const clone = media.cloneNode(true);
            clone.style.maxWidth = "100%";
            clone.style.maxHeight = "100%";

            modalContent.innerHTML = ""; // Clear previous content
            modalContent.appendChild(clone);

            modal.classList.add("active");
            // console.log("Modal activated.");
        });

        // Mark media item as having a listener attached
        media.dataset.modalListener = "true";
    });
}

// NPUB handling

const npubDefaultRelays = [
        "wss://relay.damus.io",
        "wss://njump.me",
        "wss://nos.lol"
    ];

    /**
     * Converts a `nostr:npub` string to a hexadecimal public key.
     */
function npubToHex(npub) {
    // Remove the "nostr:" prefix if it exists
    const bech32String = npub.replace("nostr:", "");

    // Decode the Bech32 string
    const decoded = bech32.decode(bech32String);

    // Convert words to bytes (5-bit to 8-bit conversion)
    const bytes = bech32.fromWords(decoded.words);

    // Convert bytes to a hexadecimal string
    return Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
}

// document.addEventListener("DOMContentLoaded", () => {
//         const testNpub = "nostr:npub1r0rs5q2gk0e3dk3nlc7gnu378ec6cnlenqp8a3cjhyzu6f8k5sgs4sq9ac";
//         console.log("Hexadecimal Key:", npubToHex(testNpub));
//     });

    /**
     * Searches metadata for a given hex public key using default relays.
     */
     async function searchMetadata(hex) {
    for (const relay of defaultRelays) {
        try {
            const socket = new WebSocket(relay);

            // Return a Promise to handle async WebSocket interactions
            return new Promise((resolve, reject) => {
                socket.onopen = () => {
                    // Send a subscription request for kind 0 events for the given public key
                    const subscriptionId = `sub_${Date.now()}`;
                    const subscriptionMessage = JSON.stringify([
                        "REQ", subscriptionId, { kinds: [0], authors: [hex] }
                    ]);
                    socket.send(subscriptionMessage);
                };

                socket.onmessage = (event) => {
                    const message = JSON.parse(event.data);

                    // Check if the message contains a kind 0 event
                    if (message[0] === "EVENT" && message[2].kind === 0) {
                        const metadata = JSON.parse(message[2].content);
                        socket.close();
                        resolve(metadata); // Resolve with the parsed metadata
                    }
                };

                socket.onerror = (error) => {
                    console.warn(`WebSocket error on relay: ${relay}`, error);
                    socket.close();
                    reject(`Failed to fetch metadata from relay: ${relay}`);
                };

                socket.onclose = () => {
                    // Reject if the connection closes without metadata
                    reject(`Connection closed before receiving metadata from relay: ${relay}`);
                };
            });
        } catch (error) {
            console.warn(`Failed to fetch metadata from relay: ${relay}`, error);
        }
    }

    // Return a default empty metadata if no relay succeeds
    return { name: null };
}


    /**
     * Generates a profile link for a given hex public key.
     */
    function generateProfileLink(hex) {
        return `https://njump.me/p/${hex}`;
    }

    /**
     * Processes a single `nostr:npub` string into its replacement HTML.
     */
     async function processNpub(npub) {
    try {
        const hex = npubToHex(npub);
        const metadata = await searchMetadata(hex);
        console.log("Metadata:", metadata); // Log metadata

        const userName = metadata.name
            ? `@${metadata.name}` // Add "@" prefix if name exists
            : `${npub.substring(0, 6)}...${npub.slice(-4)}`;

        const nip05 = metadata.nip05 || npub; // Use NIP-05 or fallback to npub
        const profileLink = generateProfileLink(hex); // Generate profile link

        return `<a href="${generateProfileLink(hex)}" title="${nip05}">${userName}</a>`;
    } catch (error) {
        console.error(`Error processing npub: ${npub}`, error);
        return `<span title="${npub}">${npub.substring(0, 6)}...${npub.slice(-4)}</span>`;
    }
}

    /**
     * Replaces all `nostr:npub` strings in the provided content with the processed HTML.
     */
     async function replaceNpubStrings(content) {
    const matches = content.match(/nostr:npub\w+/g) || [];

    // Use a Set to track processed npub strings to avoid duplicate replacements
    const uniqueMatches = new Set(matches);

    for (const npub of uniqueMatches) {
        // Skip already replaced links
        const alreadyProcessedRegex = new RegExp(
            `<a [^>]*href=[^>]*>${npub.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`,
            "g"
        );
        if (alreadyProcessedRegex.test(content)) continue;

        const replacement = await processNpub(npub);

        // Safely replace the original `nostr:npub` string in the content
        const regex = new RegExp(npub.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
        content = content.replace(regex, replacement);
    }
    console.log("Original Content:", content);
    console.log("Matches Found:", matches);
    console.log("Processed Content:", content);
    return content;
}


    /**
     * Updates the paragraph content dynamically, processing `nostr:npub` strings.
     */
    async function updateParagraphContent() {
        const paragraph = document.getElementById("customParagraph");
        const fullContent = paragraph.getAttribute("data-full-content");

        if (fullContent) {
            const processedContent = await replaceNpubStrings(fullContent);
            paragraph.innerHTML = processedContent;
        }
    }

    // Run the function after the DOM is fully loaded
    document.addEventListener("DOMContentLoaded", updateParagraphContent);


// END - NPUB handling


function setRelays(customRelays) {
    relaySubscriptions = [];
    sockets.forEach((socket) => socket.close());
    sockets = [];
    let allRelaysFailed = true;

    customRelays.forEach((url) => {
        let socket = new WebSocket(url);
        socket.onmessage = async function (m) {
            var [, i, e] = JSON.parse(m.data),
                { kind, c } = e || {};
            if (!e || e === true) return;
            console.log("msg:", e);
        };
        socket.onopen = async function (e) {
            console.log("connected to " + url);
            allRelaysFailed = false;
            var i = b2h(utils.randomPrivateKey()).substring(0, 16),
                f = { authors: [pub] },
                sub = ["REQ", i, f];
            console.log("Subscription:", sub);
            socket.send(JSON.stringify(sub));
            relaySubscriptions.push({ socket, url });
        };
        socket.onerror = function (e) {
            console.log(`Failed to connect to ${url}`);
        };
        sockets.push(socket);
    });

    setTimeout(() => {
        if (allRelaysFailed) {
            document.getElementById("relayWarning").style.display = "block";
        }
    }, 5000);
}

var h2b = (h) =>
        Uint8Array.from(h.match(/.{1,2}/g).map((b) => parseInt(b, 16))),
    b2h = (b) => b.reduce((s, b) => s + b.toString(16).padStart(2, "0"), ""),
    { schnorr, utils } = nobleSecp256k1,
    sha256 = utils.sha256,
    pk,
    pub,
    storePrivateKey = false,
    sockets = [],
    relaySubscriptions = [];

async function generateNewKeys() {
    const { ln } = getQueryParams();  // Get the ln parameter during key generation
    // Clear existing avatar URL to ensure a new one is generated
    localStorage.removeItem("avatar_url");
    localStorage.removeItem("liked_events");  // Clear liked events to prevent adoption by the new ID
    localStorage.removeItem("posted_hashes");  // Clear liked events to prevent adoption by the new ID

    pk = b2h(utils.randomPrivateKey());
    pub = nobleSecp256k1.getPublicKey(pk, true).substring(2);

    const avatarUrl = getAvatarUrl(pub); // Generate avatar URL based on pubkey
    const randomName = await generateRandomName(); // Generate random nostr_name


    // Store ln (lightning address) if available
    if (ln && ln !== '') {
        const reversedLn = ln.split('').reverse().join('');
        localStorage.setItem("ln_param", reversedLn);  // Store reversed ln address
    }

    // Store keys and avatar URL in localStorage
    localStorage.setItem("nostr_pk", pk);
    localStorage.setItem("nostr_pub", pub);
    localStorage.setItem("avatar_url", avatarUrl); // Store avatar URL
    localStorage.setItem("nostr_name", randomName); // Store the generated name
    localStorage.setItem("acc_created_at", Math.floor(Date.now() / 1000)); // Store current account birthday

    // Store in HEX.json for record keeping
    const fileName = `HEX${pub}.json`;
    const eventData = {
        pubkey: pub,
        pk: pk,
        avatar: avatarUrl,
        name: randomName, // Store the name in the local storage for this key
        created_at: Math.floor(Date.now() / 1000),
    };
    localStorage.setItem(fileName, JSON.stringify(eventData));

    // Post Metadata to Relays (NIP-05 kind 0)
    postMetadata(pub, avatarUrl, randomName);

    // Update .well-known/nostr.json on the server
    await updateNostrJson(randomName, pub);

    updateAvatar();
    updateNostrNameDisplay();  // Update the nostr_name display immediately
    // console.log(`New keys generated. Avatar URL: ${avatarUrl}`);
    // console.log("Generated name:", randomName);

    // --- Modal for Key generation with Alert ---
    const storeKeyResponse = confirm(
        "A random Nostr ID was created.\n\n" +
        "Do you want to store the private key in your device memory for future use in other clients?\n\n" +
        "By clicking 'OK', the private key will be stored locally on your device. To access it later, visit the 'Show History' button at the bottom of the page."
    );

    if (storeKeyResponse) {
        storePrivateKey = true;
        localStorage.setItem("store_private_key", storePrivateKey);
        localStorage.setItem("nostr_pk", pk);
        alert("Private key stored successfully!");
    } else {
        storePrivateKey = false;
        localStorage.setItem("store_private_key", storePrivateKey);
        alert("Private key was not stored.");
    }
}

// Fallback - Generate random string for errors
function generateRandomFallback() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    return Array.from(
        { length: 10 },
        () => chars[Math.floor(Math.random() * chars.length)]
    ).join("");
}

// Function to generate random name from adjectives and nouns
async function generateRandomName() {
    try {
        const adjectives = await loadJson("adjectives.json");
        const nouns = await loadJson("nouns.json");

        const randomNumber = String(
            Math.floor(Math.random() * 21) + 1
        ).padStart(2, "0"); // 01 to 21
        const randomAdjective =
            adjectives[Math.floor(Math.random() * adjectives.length)];
        const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];

        return `${randomAdjective}_${randomNoun}_${randomNumber}`;
    } catch (error) {
        // console.error("Error generating random name:", error);
        return generateRandomFallback(); // Return random string if JSON fails
    }
}

// Kind 0
async function postMetadata() {
    const { ln } = getQueryParams();
    let name = localStorage.getItem("nostr_name"); // Get the name from localStorage
    const avatarUrl = localStorage.getItem("avatar_url") || getAvatarUrl(pub); // Fetch existing avatar or regenerate

    // If name is missing, generate and store it
    if (!name) {
        name = await generateRandomName();
        localStorage.setItem("nostr_name", name);
    }

    // Decode the lightning address if ln exists and is not empty
    let lud16Value = `${name.toLowerCase()}@postanote.org`;  // Default to nostrName
    if (ln && ln !== '') {
        lud16Value = decodeURIComponent(ln.split('').reverse().join(''));  // Reverse and decode
    }

    // Array of banner URLs
    const bannerUrls = [
        "https://i.ibb.co/Qc5BWcb/Notes-fallin-from-the-sky.webp",
        "https://i.ibb.co/JnscKRr/bookclub.webp",
        "https://i.ibb.co/hf3pMzd/papernotes.webp",
        "https://i.ibb.co/93Gw99b/notes-In-Restaurant.webp",
        "https://i.ibb.co/WxyZ6SW/notes-Adventure.webp"
    ];

    // Pick a random banner URL
    const randomBanner = bannerUrls[Math.floor(Math.random() * bannerUrls.length)];

    // const nostrName = `_@postanote.org`;  // Create nip05 address
    const nostrName = `${name.toLowerCase()}@postanote.org`; // Create nip05 address <- Future unique names added to the .well-known folder
    const currentTime = Math.floor(Date.now() / 1000);

    // Metadata structure
    const metadata = {
        lud16: lud16Value, // lightning address as name@postanote.org) Can be custom if ln= in URL is included
        lud06: "", // Old lightning addresses style
        picture: avatarUrl,
        name: name,
        about: "Apparently, I'm one of the Nostriches posting random thoughts and notes the plebs set me up for. I didn't know I signed up for this, but here we are.",
        website: "https://postanote.org",
        banner: randomBanner,  // Use random banner
        display_name: name,
        nip05: nostrName,
        pubkey: pub,
        npub: "",
        created_at: currentTime,

        // is_deleted: false
    };

    const metadataEvent = {
        pubkey: pub,
        content: JSON.stringify(metadata), // Stringified JSON as required by NIP-01
        created_at: currentTime,
        kind: 0, // Kind 0 for metadata
        tags: [
            [
                "alt",
                `Random Nostrich ${name} who's avatar was created with dicebear.com API for use in postanote.org`,
            ],
            // ["i", `nostr:${name}`, b2h(await sha256(new TextEncoder().encode(name)))]
        ],
    };

    // Generate event ID and signature
    metadataEvent.id = b2h(
        await sha256(
            new TextEncoder().encode(
                JSON.stringify([
                    0,
                    metadataEvent.pubkey,
                    metadataEvent.created_at,
                    metadataEvent.kind,
                    metadataEvent.tags,
                    metadataEvent.content,
                ])
            )
        )
    );

    metadataEvent.sig = await schnorr.sign(metadataEvent.id, pk);

    // Send to relays
    relaySubscriptions.forEach(({ socket, url }) => {
        socket.send(JSON.stringify(["EVENT", metadataEvent]));
        console.log(`Metadata event sent to ${url}`);
    });

    // console.log("Metadata event:", metadataEvent);

    // Update the HEX.json for the generated profile
    const fileName = `HEX${pub}.json`;
    const storedProfile = JSON.parse(localStorage.getItem(fileName)) || {};
    storedProfile.nostr_name = name;
    localStorage.setItem(fileName, JSON.stringify(storedProfile));

    // Post to .well-known/nostr.json (via fetch or server-side script)
    updateNostrJson(name, pub);
}

async function updateNostrJson(name, pubkey) {
    const wellKnownData = {
        names: {
            [name]: pubkey,
        },
    };

    try {
        const response = await fetch("/.well-known/nostr.json", {
            method: "POST", // Or PUT, depending on server config
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(wellKnownData),
        });

        if (response.ok) {
            console.log("nostr.json updated successfully.");
        } else {
            console.error("Failed to update nostr.json.");
        }
    } catch (error) {
        console.error("Error updating nostr.json:", error);
    }
}

function loadKeys() {
    const storedPk = localStorage.getItem("nostr_pk");
    const storedPub = localStorage.getItem("nostr_pub");
    const storedStorePrivateKey =
        localStorage.getItem("store_private_key") === "true";

    if (storedPk && storedPub) {
        pk = storedPk;
        pub = storedPub;
        storePrivateKey = storedStorePrivateKey;

        // Retrieve avatar URL from HEX.json
        const storedData = localStorage.getItem(`HEX${pub}.json`);
        if (storedData) {
            const parsedData = JSON.parse(storedData);
            const avatarUrl = parsedData.avatar || getAvatarUrl(pub); // Fallback to generate if missing
            localStorage.setItem("avatar_url", avatarUrl); // Ensure avatar URL is stored
        }

        updateAvatar();
        // console.log("Keys and avatar loaded from storage.");
    } else {
        // generateNewKeys();
        console.log("No keys in localStorage. Keys must be generated separately.");
    }
}

// check for posted events in localStorage
function checkIfPostsExist() {
    const currentPubKey = localStorage.getItem("nostr_pub");
    if (!currentPubKey) {
        console.log("No current pubkey found.");
        return false;
    }

    const fileName = `HEX${currentPubKey}.json`;
    const storedData = localStorage.getItem(fileName);
    if (!storedData) {
        console.log("No entry found for current pubkey.");
        return false;
    }

    let parsedData;
    try {
        parsedData = JSON.parse(storedData);
    } catch (error) {
        // console.error("Error parsing stored data:", error);
        return false;
    }

    // Check for events inside the stored data
    if (parsedData.events && parsedData.events.length > 0) {
        // console.log(`Found ${parsedData.events.length} event(s).`);
        return true;
    } else {
        // console.log("No events found for this account.");
        return false;
    }
}

// Get Account Creation Time from acc_created_at (not event-based)
function getAccountCreationTime() {
    const accountCreationTime = localStorage.getItem("acc_created_at");
    if (!accountCreationTime) {
        // console.log("No account creation time found in localStorage.");
        return null;
    }
    return parseInt(accountCreationTime, 10);  // Ensure it's an integer
}

// checks the age of the current account.
function checkAccountAge() {
    const accountCreationTime = getAccountCreationTime();
    const currentTime = Math.floor(Date.now() / 1000);

    if (!accountCreationTime) {
        // console.log("No creation time found in localStorage.");
        return 21000000; // Block indefinitely if no creation time
    }

    const ageInSeconds = currentTime - accountCreationTime;
    const remainingSeconds = 86400 - ageInSeconds; // 24h
    // const remainingSeconds = 86400 - ageInSeconds; // 24h

    // console.log("Account Age (seconds):", ageInSeconds);
    // console.log(
    //     "Remaining Minutes:",
    //     Math.max(Math.ceil(remainingSeconds / 60), 0)
    // );

    // If negative, return 0 (means they can create a new ID)
    return Math.max(Math.ceil(remainingSeconds / 60), 0);
}

// Avatar click handler with countdown message
document.getElementById("avatarIcon").onclick = function () {
    const pkExists = localStorage.getItem("nostr_pk");
    const urlParams = new URLSearchParams(window.location.search);

    // Block new ID generation without URL parameters
    if (!urlParams.toString()) {
        alert("Cannot generate new ID if not used with custom sites.");
        return;
    }

    // If no private key exists, force ID generation without post requirement
    if (!pkExists) {
        generateNewKeys();
        alert("New ID generated.");
        return;
    }

    const hasPosts = checkIfPostsExist();
    const remainingMinutes = checkAccountAge();

    // console.log("Remaining Minutes:", remainingMinutes);
    // console.log("Has Posts:", hasPosts);

    // Check if account is too new
    if (remainingMinutes > 0 && remainingMinutes < 21000000) {
        alert(
            `Your account is too new to generate a new ID. Please retry after ${remainingMinutes} minute(s).`
        );
        return;
    } else if (remainingMinutes >= 21000000) {
        alert(
            "Your account is not eligible to generate a new ID yet. Please post something first."
        );
        return;
    }

    if (!hasPosts) {
        alert("You must post at least once before generating a new ID.\n\n\
If you need a suggestion just post GM or GN ");
        return;
    }

    // Confirm ID regeneration
    if (
        confirm(
            "Are you sure you want to generate a new random ID? This will replace your current one.\n\n\
All your previous IDs used with this domain are stored locally with all other details. You can easily reuse them in other Nostr clients if needed.\n\n\
To access your history in your device memory, please check the showHistory button at the bottom of the page."
        )
    ) {
        generateNewKeys();
        alert("New ID generated.");
    } else {
        alert("Cancelled.");
    }
};


function checkIfPostsExist() {
    const currentPubKey = localStorage.getItem("nostr_pub");
    if (!currentPubKey) {
        // console.log("No current pubkey found.");
        return false;
    }

    const fileName = `HEX${currentPubKey}.json`;
    const storedData = localStorage.getItem(fileName);
    if (!storedData) {
        // console.log("No entry found for current pubkey.");
        return false;
    }

    const parsedData = JSON.parse(storedData);
    if (parsedData.events && parsedData.events.length > 0) {
        // console.log("Events found for current pubkey.");
        return true;
    } else {
        // console.log("No events found for this account.");
        return false;
    }
}

// Hashing the content to prevent posting duplicates
// Simple SHA-256 hashing function
async function hashContent(content) {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((byte) => byte.toString(16).padStart(2, "0")).join("");
}

// Save hash to localStorage
function saveHash(hash) {
    let hashes = JSON.parse(localStorage.getItem("posted_hashes")) || [];
    hashes.push(hash);
    localStorage.setItem("posted_hashes", JSON.stringify(hashes));
}

// Check if the content hash already exists
function isDuplicateContent(hash) {
    const hashes = JSON.parse(localStorage.getItem("posted_hashes")) || [];
    return hashes.includes(hash);
}


document.getElementById("sendMessageBtn").onclick = async () => {

    const urlParams = new URLSearchParams(window.location.search);

    // Block if no query parameters exist
    if (!urlParams.toString()) {
        alert("Cannot send messages. Please use custom websites to use this tool");
        return;  // Prevent further execution
    }

    // Proceed if parameters exist
    if (!localStorage.getItem("nostr_pk")) {
        alert(
            "No private key found.\n\n\
Private keys are needed to sign messages\n\n\
Please generate a new ID by pressing OK."
        );
        generateNewKeys();
        return;
    }

    // Prevent Posting Without ID
    if (!localStorage.getItem("nostr_pk")) {
        alert(
            "No private key found. please generate a new ID by pressing OK btn."
        );
        generateNewKeys(); // Regenerate the key if needed
        return; // Stop execution if no key is present
    }

    // 2. Proceed with Message Sending Logic
    const um = document.getElementById("userMessage").value,
        embeddedHashtags = document
            .getElementById("userMessage")
            .getAttribute("data-hashtags")
            .split(",")
            .filter(Boolean),
        additionalHashtags = ["postanote"], // hardcoded hashtags. these will be always included when messages are created and posted from your custom domain instance
        allHashtags = [...embeddedHashtags, ...additionalHashtags]
            .map((tag) => `#${tag.trim()}`)
            .join(" "),
        fullMessage = `${um} ${allHashtags}`;

    // Hash the content
    const contentHash = await hashContent(fullMessage);

    // Check for duplicates
    if (isDuplicateContent(contentHash)) {
        if (
            confirm(
                "This exact message was already posted! Posting the same content repeatedly is not allowed."
            )
        ) {
            console.log("duplicate post prevented")
        }
        return;
    }

    const tags = allHashtags
            .split(" ")
            .filter(Boolean)
            .map((tag) => ["t", tag.replace("#", "")]),
        ev = {
            content: fullMessage,
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: tags,
            pubkey: pub,
        }, // <- Here I can add additional attributes that needed to be signed
        sev = await signEvent(ev, pk);

    // Reorder attributes of the signed event here (optional)
    const orderedEvent = {
        content: sev.content,
        created_at: sev.created_at,
        id: sev.id,
        kind: sev.kind,
        pubkey: sev.pubkey,
        sig: sev.sig,
        tags: sev.tags,
        // add more if necessary
    };

    // console.log("signedEvent:", sev);
    relaySubscriptions.forEach(({ socket, url }) => {
        socket.send(JSON.stringify(["EVENT", orderedEvent])); // Send reordered event
        console.log(`Event sent to ${url}`, orderedEvent);
    });

    // Save hash to prevent duplicate posts
    saveHash(contentHash);

    // Update the status message
    const statusMessage = document.getElementById("statusMessage");
    statusMessage.textContent = "Message has been sent.";

    // Clear Previous Event Details
    const eventDetails = document.getElementById("eventDetails");
    eventDetails.innerHTML = ""; // Clear previous content _ Comment out this line if we need to append all posted notes in the screen session

    // Show New Event Details
    eventDetails.innerHTML += `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <button class="close-event-btn" onclick="closeEventSentDetails()" title="Close this section">‚ùå</button>
                <h3>Event Details</h3>
            </div>
            <pre>${JSON.stringify(sev, null, 2)}</pre>
            <div style="display: flex; flex-direction: column; align-items: center; margin-top: 10px;">
                <button class="copy-btn" onclick="copyMessageId('${sev.id}')" title="copy the event ID">Copy Note ID</button>
                <button class="copy-btn" onclick="window.open('https://njump.me/${sev.id}', '_blank')" title="View this event on njump.me">üëÄ njump.me</button>
            </div>
        `;
    eventDetails.style.display = "block";

    // Smooth Scroll to Status Message
    statusMessage.scrollIntoView({
        behavior: "smooth",
        block: "center", // Scroll to center the element
    });

    // Attach click outside to close the eventDetails
    document.addEventListener('click', function (e) {
        const eventDetails = document.getElementById("eventDetails");
        if (eventDetails.style.display === "block" && !eventDetails.contains(e.target)) {
            closeEventSentDetails();
        }
    });

    saveEvent(sev);

   // **Delete private key if store_private_key is false**
    const shouldDeleteKey = localStorage.getItem('store_private_key') === 'false';
        if (shouldDeleteKey) {
            // console.log('Deleting private key (nostr_pk) from storage...');
            localStorage.removeItem('nostr_pk');
        }
};

// Close the (after posting) Event Details 
function closeEventSentDetails() {
    const eventDetails = document.getElementById("eventDetails");
    const statusMessage = document.getElementById("statusMessage");
    eventDetails.style.display = "none";
    statusMessage.style.display = "none";
}

async function signEvent(ev, pk) {
    const ed = JSON.stringify([
        0, // Nostr spec prefix (for signing)
        ev.pubkey,
        ev.created_at,
        ev.kind,
        ev.tags,
        ev.content,
    ]);

    ev.id = b2h(await sha256(new TextEncoder().encode(ed))); // Hash the event to create the ID
    ev.sig = await schnorr.sign(ev.id, pk); // Sign the ID with the private key

    return ev; // Return the signed event
}

function copyMessageId(messageId) {
    navigator.clipboard.writeText(messageId).then(() => {
        alert("Message ID copied to clipboard");
    });
}

function adjustHeight(el) {
    el.style.height = "auto";
    el.style.height = el.scrollHeight + "px";
}

function saveEvent(event) {
    const fileName = `HEX${pub}.json`;
    let storedData = localStorage.getItem(fileName);
    let events = [];

    if (storedData) {
        storedData = JSON.parse(storedData);
        events = storedData.events || [];
    }

    // Attach identity metadata directly to the event
    event.avatar = localStorage.getItem("avatar_url") || "";
    event.nostr_name = localStorage.getItem("nostr_name") || "";

    events.push({
        ...event,
        subscribedRelays: relaySubscriptions.map(
            (subscription) => subscription.url
        ), // Add this line to include the relays
    });

    if (storePrivateKey) {
        localStorage.setItem(fileName, JSON.stringify({ events, pk }));
    } else {
        localStorage.setItem(fileName, JSON.stringify({ events }));
    }
}

function generateQRCode(pk) {
    const qrCodeContainer = document.getElementById("qr-code");
    qrCodeContainer.innerHTML = "";  // Clear previous QR codes

    // Generate URL for private key import (adjust as necessary)
    const importUrl = `nostr:npub/${pk}`;

    // Create QR Code using EasyQRCodeJS
    new QRCode(qrCodeContainer, {
        text: importUrl,
        width: 500,
        height: 500,
        colorDark: "#000000",
        colorLight: "#ffffff",
        logo: "img/QRcode_logo/nostrUniverse.png",  // Add your logo URL here
        logoWidth: 75,
        logoHeight: 75,
        title: "Import private key to Nostr app",
        // titleFont: "2em",
        titleColor: "#000000",
        titleBackgroundColor: "#ffffff",
        titleHeight: 30,
        titleTop: 15,
    });

    // Temporarily hide notesModal to avoid overlay issues
    document.getElementById("notesModal").style.display = "none";

    // Temporarily hide nostrNameDisplay
    document.getElementById("nostrNameDisplay").style.display = "none";
    document.getElementById('qr-modal').style.display = 'flex';

    // Show QR modal
    document.getElementById('qr-modal').style.display = 'flex';
}

// Close QR modal and restore notesModal
document.getElementById('close_qr_button').addEventListener('click', function () {
    document.getElementById('qr-modal').style.display = 'none';
    
    // Reopen the notesModal
    document.getElementById("notesModal").style.display = "block";

    // add back nostr_name
    document.getElementById("nostrNameDisplay").style.display = "block";
});

// Function to generate bright colors from public key
function generateColorFromPubKey(pubkey) {
    const hash = Array.from(pubkey).reduce(
        (acc, char) => acc + char.charCodeAt(0),
        0
    );
    const hue = hash % 360; // Full spectrum of colors
    const saturation = 70 + (hash % 20); // Bright saturation (70-90%)
    const lightness = 50 + ((hash >> 3) % 20); // Mid brightness (50-70%)

    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

function loadStoredEvents() {
    const keys = Object.keys(localStorage).filter((key) =>
        key.startsWith("HEX")
    );
    const notesModalContent = document.getElementById("notesModalContent"); // Only dynamic content is affected
    const panicContainer = document.querySelector(".panic-container");

    // Clear modal content
    notesModalContent.innerHTML = "";

    // Re-add the download button
    const downloadButton = document.createElement("button");
    downloadButton.id = "downloadDataBtn";
    downloadButton.textContent = "Download history";
    downloadButton.style =
        "background-color: #ff00006e; color: #efefef; border: none; border-radius: 5px; cursor: pointer;";
    downloadButton.onclick = function () {
        // console.log("Download button clicked");
        downloadData();
    };
    notesModalContent.appendChild(downloadButton);

    // Gather and prepare all events sorted by public key's latest event timestamp
    let allIdentities = [];

    keys.forEach((key) => {
        const storedData = JSON.parse(localStorage.getItem(key));
        const events = storedData.events || [];
        const storedPk = storedData.pk;
        const pubkey = key.replace("HEX", "");

        // Extract nostr_name from the first event, fallback if not available
        const nostrName = events.length > 0
            ? events[0].nostr_name || "Unknown Nostr User"
            : "Unknown Nostr User";

        // Attach public key and color to each identity
        if (events.length > 0) {
            const latestTimestamp = Math.max(
                ...events.map((e) => e.created_at)
            );
            allIdentities.push({
                pubkey: pubkey,
                events: events.sort((a, b) => b.created_at - a.created_at), // Sort events within the identity
                pk: storedPk,
                color: generateColorFromPubKey(pubkey),
                latestTimestamp: latestTimestamp,
                nostrName: nostrName,  // Attach nostr_name from the first event
            });
        }
    });

    // Sort identities by the latest note timestamp (newest first)
    allIdentities.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // Display each identity and its sorted notes
    allIdentities.forEach((identity) => {
        const { pubkey, events, pk, color, nostrName } = identity;

        // Create div for this identity
        const keyDiv = document.createElement("div");
        keyDiv.innerHTML = `<h5>(${events.length}) posted notes as ${nostrName}@postanote.org\n
${pubkey}</h5>`;
        keyDiv.style.color = color;

        // Create wrapper div for flex alignment
        const pkContainer = document.createElement("div");
        pkContainer.style.display = "flex";
        pkContainer.style.alignItems = "center";  // Vertically align
        pkContainer.style.justifyContent = "space-between";  // Push QR to the right
        pkContainer.style.width = "100%";        

        // Add private key span right after the identity label
        if (pk) {
            const pkSpan = document.createElement("span");
            pkSpan.textContent =
                "Hidden private key ******************************";
            pkSpan.title = "Click to reveal the private key";
            pkSpan.style.cursor = "pointer";
            pkSpan.style.display = "block";
            pkSpan.style.marginTop = "10px";
            pkSpan.style.flex = "1";  // Allow span to take up remaining space

            // QR code icon
            const qrIcon = document.createElement("img");
            qrIcon.src = "img/QRcode_logo/qr-code-icon.png";  // Use your QR icon path
            qrIcon.style.width = "75px";
            qrIcon.style.cursor = "pointer";
            qrIcon.style.marginLeft = "10px";
            qrIcon.title = "Generate QR Code for easy import into your nostr app";
            qrIcon.style.zIndex = "10001";

            qrIcon.onclick = () => {
                generateQRCode(pk);
            };

            // Countdown span (for visual countdown)
            const countdownSpan = document.createElement("span");
            countdownSpan.style.marginLeft = "10px";
            countdownSpan.style.color = "red";
            countdownSpan.id = `countdown-${pubkey}`;

            pkSpan.onclick = () => {
                if (confirm(`Reveal secret key for ${pubkey}?`)) {
                    pkSpan.textContent = pk;
                    let countdown = 10;

                    // Show countdown at the top
                    let countdownOverlay =
                        document.getElementById("countdownOverlay");
                    if (!countdownOverlay) {
                        countdownOverlay = document.createElement("div");
                        countdownOverlay.id = "countdownOverlay";
                        countdownOverlay.style.position = "fixed";
                        countdownOverlay.style.top = "50%";
                        countdownOverlay.style.left = "50%";
                        countdownOverlay.style.transform = "translateX(-50%)";
                        countdownOverlay.style.fontSize = "2rem";
                        countdownOverlay.style.color = "#ff0000";
                        countdownOverlay.style.zIndex = "1001";
                        countdownOverlay.style.display = "block";
                        document.body.appendChild(countdownOverlay);
                    }

                    countdownOverlay.textContent = `${countdown}s`;

                    const countdownInterval = setInterval(() => {
                        countdown -= 1;
                        if (countdown > 0) {
                            countdownOverlay.textContent = `${countdown}s`;
                        } else {
                            clearInterval(countdownInterval);
                            pkSpan.textContent =
                                "Hidden private key ******************************";
                            countdownOverlay.style.display = "none";
                        }
                    }, 1000);
                }
            };

        // Append private key and QR icon to the flex container
        pkContainer.appendChild(pkSpan);
        pkContainer.appendChild(qrIcon);

        // Append the flex container to the modal content
        keyDiv.appendChild(pkContainer);
        }

        // Append each event under the identity
        events.forEach((event) => {
            const eventPre = document.createElement("pre");
            eventPre.textContent = JSON.stringify(event, null, 2);
            eventPre.style.borderLeft = `5px solid ${color}`; // Color left border of each event
            keyDiv.appendChild(eventPre);
        });

        notesModalContent.appendChild(keyDiv);
    });

    // Ensure the panic button is always at the bottom
    if (panicContainer) {
        notesModalContent.parentNode.appendChild(panicContainer);
    }

    // console.log("Checking button after loadStoredEvents:");
    // console.log(document.getElementById("downloadDataBtn"));
}

document.getElementById("wipeStorageBtn").onclick = function () {
    if (
        confirm(
            "‚ö†Ô∏è Are you sure you want to delete ALL your previous activity on this domain? This action cannot be undone."
        )
    ) {
        if (
            confirm(
                "‚ùóÔ∏è Are you 100% sure?\n\n\
This will permanently wipe all your previous activity!\n\n\
You can still go back by clicking CANCEL button and export your history via showHistory which you can find on the bottom of the page.\n\n\
This was your last warning! By clicking OK, you will wipe your previous interactions with this page."
            )
        ) {
            localStorage.clear();
            alert("All data has been erased.");
            location.reload(); // Reload to reflect changes
        } else {
            alert("Cancelled.");
        }
    } else {
        alert("Cancelled.");
    }
};

// Show the modal with sorted notes
document.getElementById("showHistoryBtn").onclick = function () {
    loadStoredEvents();
    const modal = document.getElementById("notesModal");
    modal.style.display = "block";
    // console.log("Modal visibility:", modal.style.display);
};

// Close modal when clicking outside the content
document.getElementById("notesModal").onclick = function (event) {
    if (event.target === this) {
        this.style.display = "none";
    }
};

function downloadData() {
    const keys = Object.keys(localStorage).filter((key) =>
        key.startsWith("HEX")
    );
    let allData = {};

    keys.forEach((key) => {
        const storedData = JSON.parse(localStorage.getItem(key));
        allData[key] = storedData;
    });

    const dataStr = JSON.stringify(allData, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `account_data_${new Date()
        .toISOString()
        .replace(/[:.]/g, "-")}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

document.addEventListener("DOMContentLoaded", () => {
    // console.log("Button exists:", document.getElementById("downloadDataBtn"));
    const btnStyle = getComputedStyle(
        document.getElementById("downloadDataBtn")
    );
    // console.log("Button visibility:", btnStyle.display, btnStyle.visibility);
});

// download the user data in .JSON
document.addEventListener("DOMContentLoaded", () => {
    const downloadButton = document.getElementById("downloadDataBtn");
    if (downloadButton) {
        downloadButton.onclick = function () {
            // console.log("Download button clicked"); // Confirm click
            downloadData();
        };
    } else {
        // console.error("Download button not found!");
    }
});

document.getElementById("userMessage").oninput = function () {
    const um = document.getElementById("userMessage").value;
    const charCount = document.getElementById("charCount");
    const sendMessageBtn = document.getElementById("sendMessageBtn");
    const userMessage = document.getElementById("userMessage");
    const maxLength = userMessage.getAttribute("maxlength");

    charCount.textContent = `${um.length}/${maxLength}`;

    if (um.trim().length === 0 || um.length > maxLength) {
        sendMessageBtn.disabled = true;
    } else {
        sendMessageBtn.disabled = false;
    }

    if (um.length >= maxLength) {
        userMessage.style.borderBottom = "5px solid red";
    } else {
        userMessage.style.borderBottom = "5px solid #00ff55";
    }

    adjustHeight(this);
};


document.addEventListener('DOMContentLoaded', () => {
    const sendMessageBtn = document.getElementById("sendMessageBtn");
    const avatarIcon = document.getElementById("avatarIcon");
    const warningMessage = document.getElementById("warningMessage");
    const urlParams = new URLSearchParams(window.location.search);

    if (!urlParams.toString()) {
        sendMessageBtn.disabled = true;
        avatarIcon.style.pointerEvents = "none";
        avatarIcon.style.opacity = "0.5";
        // console.log("No URL attributes detected. Send button and avatar are disabled to avoid spam IDs and Notes.");

        // Show the warning message
        warningMessage.style.display = "block";
        // console.log("No URL attributes detected. Send button and avatar are disabled to avoid spam IDs and Notes.");
    } else {
        // Allow `oninput` to handle enabling/disabling the button
        const userMessage = document.getElementById("userMessage");
        if (userMessage.value.trim().length === 0) {
            sendMessageBtn.disabled = true; // Ensure the button stays disabled for empty messages
        }
        avatarIcon.style.pointerEvents = "auto";
        avatarIcon.style.opacity = "1"; // Re-enable the avatar icon if URL params exist
    }
});



// Show the password modal when the page loads
document.addEventListener('DOMContentLoaded', function () {
    const modal = document.getElementById('passwordModal');
    const submitButton = document.getElementById('submitPassword');
    const passwordInput = document.getElementById('passwordInput');
    const errorText = document.getElementById('passwordError');
    const notificationBanner = document.getElementById('passwordNotification');
    const clearHashesButton = document.getElementById('clearHashes');
    const passwordHint = document.getElementById('passwordHint');

    const url = window.location.href;
    const urlParams = new URLSearchParams(window.location.search);

    // Initially hide the error message
    errorText.style.display = 'none';

    // Check for the hint in the URL (c= parameter)
    const hint = urlParams.get('c');
    if (hint) {
        passwordHint.textContent = `${decodeURIComponent(hint)}`;
        passwordHint.style.display = 'block'; // Show the hint
    }

    // If the URL is already decrypted, skip the process
    if (isUrlDecrypted(url)) {
        // console.log("URL is already decrypted. No further action required.");
        return;
    }

    // Check if the URL was previously decrypted
    if (wasUrlDecrypted(url)) {
        // console.log("Previously decrypted URL detected. Redirecting...");
        const storedPassword = localStorage.getItem('storedPassword'); // Retrieve the stored password
        if (storedPassword) {
            // Show the notification banner
            notificationBanner.style.display = 'block';

            // Redirect after a short delay to give time for reading the message
            setTimeout(() => {
                decryptAndRedirect(url, storedPassword);
            }, 15000);

            // Clear hashes on button click
            clearHashesButton.addEventListener('click', function () {
                localStorage.removeItem('decryptedUrlHash');
                localStorage.removeItem('storedPassword');
                notificationBanner.style.display = 'none';
                alert("Hashes cleared. You will be prompted for the password next time.");
            });

            return;
        }
    }

    // Show the modal for new decryption attempts
    // console.log("Showing the password modal for decryption.");
    modal.classList.add('active');

    // Trigger submit on Enter key press
    passwordInput.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') {
        event.preventDefault(); // Prevent default form submission behavior
        submitButton.click(); // Simulate submit button click
        }
    });

    submitButton.addEventListener('click', function () {
        const password = passwordInput.value.trim();

        if (!password) {
            errorText.textContent = "Password cannot be empty!";
            errorText.style.display = 'block';
            return;
        }

        const success = decryptAndRedirect(url, password);

        if (success) {
            // console.log("Decryption successful, hiding modal...");
            // const decryptedUrl = window.location.href.split('?')[0]; // Base URL
            storeDecryptedUrl(url); // Save decrypted URL hash
            localStorage.setItem('storedPassword', password); // Save the password
            modal.classList.remove('active'); // Hide the modal
        } else {
            errorText.textContent = "Invalid password or corrupted data!";
            errorText.style.display = 'block';
        }
    });
    
    // Hide error message when user starts typing
    passwordInput.addEventListener('input', function () {
        errorText.style.display = 'none';
    });
});


window.addEventListener('pageshow', function (event) {
    const modal = document.getElementById('passwordModal');
    const urlParams = new URLSearchParams(window.location.search);

    // Hide modal if the page is restored from the back/forward cache without an 'x' parameter
    if (!urlParams.has('x')) {
        modal.style.display = 'none';
        // console.log("Page restored from back/forward cache. No 'x' parameter. Hiding modal.");
    }
});

// Get the image element of the send btn running ostrich
const animatedImg = document.getElementById('animatedImg');

// Start the animation when the page loads
window.addEventListener('DOMContentLoaded', () => {
    animatedImg.classList.add('animate');
});

document.getElementById("useDefaultRelaysBtn").onclick = function () {
    document.getElementById("relayWarning").style.display = "none";
    setRelays([
        "wss://relay.nostr.band",
        "wss://relay.damus.io",
        "wss://njump.me",
        "wss://relay.snort.social",
        "wss://nos.lol",
    ]);
};
document.getElementById("closeRelayWarning").onclick = function () {
    document.getElementById("relayWarning").style.display = "none";
};

// Apply tilt after name update
document.addEventListener('DOMContentLoaded', () => {
    updateNostrNameDisplay();
    applyRandomTiltForNostrName();
});

// Load keys and set dynamic content based on URL parameters
loadKeys();
setDynamicContent();
updateAvatar();


// Prevent key generation from happening twice
document.addEventListener('DOMContentLoaded', () => {
    const pkExists = localStorage.getItem("nostr_pk");
    const pubExists = localStorage.getItem("nostr_pub");

    if (!pkExists || !pubExists) {
        // If no keys exist, generate new ones
        // console.log("No existing keys found. Generating new keys...");
        generateNewKeys();
    } else {
        // If keys exist, load them
        loadKeys();
        // console.log("Existing keys loaded.");
    }
});

</script>
<script src="footer.js"></script>       

</body>

</html>
