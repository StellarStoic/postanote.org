<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>snofl_searcher</title>

    <!-- Favicon for most browsers -->
    <link rel="icon" href="/img/favicon_io/favicon.ico" type="image/x-icon">
    
    <!-- PNG icons for better resolution -->
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png">
    
    <!-- Apple Touch Icon (for iOS) -->
    <link rel="apple-touch-icon" href="/img/favicon_io/apple-touch-icon.png">
    
    <!-- Web Manifest (for PWAs) -->
    <link rel="manifest" href="/img/favicon_io/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>snofl discovery client</title>
    <style>
        @import url(https://fonts.bunny.net/css?family=athiti:200);
        /* Root font-size scaling based on viewport width */
        html {
            font-size: calc(1vw + 1vh + 0.5vmin); /* Adjusts base font size based on the viewport */
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Athiti', sans-serif;
            background-color: black;
            color: rgb(255, 255, 255);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            width: 99vw;
            max-width: 800px;
            height: 100vh;
            overflow-y: scroll;
            scrollbar-width: none;  /* For Firefox */
            -ms-overflow-style: none;  /* For Internet Explorer/Edge */
            border: 1px solid transparent;  /* Default no border */
            transition: border-color 0.3s, box-shadow 0.3s;  /* Smooth transitions */
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        .container::-webkit-scrollbar {
            display: none;  /* For Chrome, Safari, and Opera */
        }

        .fetch-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: yellow;
            display: none;  /* Hidden by default */
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        .container.fetching {
            border-color: yellow;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);  /* Glowing yellow border */
        }

        .container.success {
            border-color: green;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);  /* Green glow when successful */
        }

        .container.error {
            border-color: red;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);  /* Red glow on error */
        }

        #notes {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 40px;
        }

        .note {
            background-color: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            position: relative;
        }

        .highlight {
            font-weight: bold;
            color: rgb(216, 101, 255);
        }

        .hashtag {
            font-weight: bold;
            color: rgb(46, 233, 46);
        }

        .note-header {
            display: flex;
            align-items: flex-start;
            margin-bottom: 5px;
        }
        .note-header img {
            width: 30px;
            height: 30px;
            border-radius: 3px;
            margin-right: 10px;
        }
        .note-content {
            word-wrap: break-word;
            margin-top: 10px;
            text-align: left;
        }
        .title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1rem;
        }
        .nip05 {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 40px;
        }

        .profile-img:hover {
            cursor: pointer;
            opacity: 0.8;
        }

        .note-content img {
            max-width: 100px;
            max-height: 100px;
            cursor: pointer;
            margin-top: 10px;
        }
        .fullscreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .fullscreen img {
            max-width: 90%;
            max-height: 90%;
        }
        .fullscreen.active {
            display: flex;
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: green;
        }
        .copy-button img {
            width: 20px;
            height: 20px;
        }
        .new-notes-button {
            position: sticky;
            top: 7px;
            right: 13px;
            background-color: green;
            color: black;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 99999;
            display: none;
        }

        .note-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .note-icons {
            display: flex;
            gap: 15px;
            font-size: 0.5rem;
        }

        .icon:hover {
            cursor: pointer;
            opacity: 0.7;
        }

        .note-timestamp {
            font-size: 0.5rem;
            color: #aaa;
            text-align: right;
        }

        .keyword {
            margin: 0 5px;
            cursor: pointer;
            border-bottom: 1px dashed transparent;
            transition: all 0.3s ease;
        }

        .keyword.active {
            color: green;
            /* border-bottom: 1px dashed green; */
        }

        .keyword.toggled {
            color: rgb(157, 157, 157);
            font-style: italic;
        }

        .highlight {
            color: rgb(222, 0, 222);
            font-weight: bold;
        }

        .inactive {
            color: rgb(157, 157, 157);
            font-style: italic;
        }


        .search-bar {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .search-bar input {
            width: 60%;
            padding: 10px;
            font-size: 1rem;
            border: 1px solid green;
            background-color: black;
            color: purple;
            border-radius: 5px;
            outline: none;
        }

        .search-bar button {
            margin-left: 10px;
            padding: 10px 15px;
            font-size: 0.7rem;
            background-color: green;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .search-bar button:hover {
            opacity: 0.9;
        }

        /* <!-- Slider Styles --> */
        #timeFilterButton {
            padding: 10px 15px;
            font-size: 0.7rem;
            background-color: green;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #222;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 60%;
            text-align: center;
            color: white;
        }

        .close {
            float: right;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            color: green;
        }

        .slider {
            -webkit-appearance: none;
            width: 90%;
            height: 12px;
            background: #444;
            outline: none;
            border-radius: 10px;
            margin-top: 20px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            background: green;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.7rem;
        }


        .apply-btn:hover {
            opacity: 0.9;
        }

        /* sroll to top btn */
        .scroll-top-btn {
            position: fixed;  /* Ensure it's fixed to viewport */
            bottom: 4%;
            background-color: rgba(240, 255, 240, 0.552);
            right: 4%;
            border: none;
            border-radius: 5px;
            font-size: 1.3rem;
            cursor: pointer;
            z-index: 999;
            display: none;  /* Hidden by default */

        }

        .scroll-top-btn:hover {
            background-color: rgba(86, 168, 86, 0.798);
            transform: scale(1.1);
        }

        /* Counters container */
        #counters {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.557);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
            border: 1px solid #666;
            gap: 15px;
            display: none; /* Single display property */
            flex-direction: row; /* Add this to specify flex layout */
        }


        /* Matches counter */
        #matchesCounter {
            color: #FF9900;  /* Light blue */
        }

        .filters {
            display: flex;
            justify-content: center;
            gap: 10px;
            font-size: 0.5rem;
            margin-bottom: 10px;
        }

        .filter-toggle-btn {
            padding: 5px 10px;
            border: none;
            font-size: 0.5rem;
            background-color: rgba(128, 128, 128, 0.414);
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }

        .filter-toggle-btn.active {
            background-color: green; /*  FORCE Green when active */
        }

        .magnetButton {
            padding: 5px 10px;
            border: none;
            font-size: 0.5rem;
            background-color: rgba(128, 128, 128, 0.414);
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }

        /*  Specific Fix for Magnet Button */
        #magnetButton {
            background-color: rgba(128, 128, 128, 0.414); /* Default Gray */
        }

        #magnetButton.active {
            background-color: green !important; /*  Ensure Green when Active */
        }


        /* long notes truncation */
        /* Truncated note content */
        .truncated {
            position: relative;
            max-height: 100px; /* Adjust for a better preview size */
            overflow: hidden;
            display: block;
            text-overflow: ellipsis;
            white-space: normal;
            mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 60%, rgba(0, 0, 0, 0));
            -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 60%, rgba(0, 0, 0, 0));
            transition: max-height 0.3s ease-in-out;
        }

        /* Expand button */
        .expand-note {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 14px;
            padding: 3px 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: opacity 0.2s ease-in-out;
        }

        /* Expanded note (removes blur effect) */
        .note-content:not(.truncated) {
            max-height: none;
            mask-image: none;
            -webkit-mask-image: none;
        }

        /* Hide button styling */
        .hide-eye-button {
            background: none;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s ease-in-out;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto; /*  Center the button */
            position: relative;
        }

        .hide-eye-button img {
            width: 24px;
            height: 24px;
            transition: opacity 0.2s ease-in-out;
        }

        .hide-eye-button:hover {
            opacity: 0.7;
        }

        /* Initially hide collapsed notes */
        .collapsed-note {
            display: none;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            padding: 8px 0;
            cursor: pointer;
        }

        /* Hide the full note when toggled */
        .note.hidden .note-content,
        .note.hidden .note-footer,
        .note.hidden .note-header {
            display: none; /* Hide everything related to the note */
        }

        /* Show the collapsed version */
        .note.hidden .collapsed-note {
            display: block;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            padding: 8px 0;
            cursor: pointer;
        }


/* Bomb icon styling */
.ban-profile-button {
    background: none;
    border: none;
    cursor: pointer;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 5px; /*  Space it from the left edge */
}

.ban-profile-button img {
    width: 35px;
    height: 35px;
    transition: opacity 0.2s ease-in-out;
}

.ban-profile-button:hover img {
    opacity: 0.7;
}

    </style>
</head>
<body>
    <div class="container">
        <div class="title">Loading...</div>  <!-- Placeholder initially -->

        <!-- Search Bar -->
        <div class="search-bar">
            <button id="timeFilterButton">⏳</button>
                <input type="text" id="keywordSearch" placeholder="Search keywords">
            <button id="searchButton">🔍</button>
            <button id="sortButton" onclick="toggleSort()">Sort: Newest</button>
        </div>

        <div class="filters">
            <label>Combine</label>
            <button id="magnetButton" title="Require ALL keywords in results">🧲</button>

            <label>Sentiment:</label>
            <button class="filter-toggle-btn" id="sentiment-negative" data-value="negative">🟥 Negative</button>
            <button class="filter-toggle-btn" id="sentiment-neutral" data-value="neutral">🟨 Neutral</button>
            <button class="filter-toggle-btn" id="sentiment-positive" data-value="positive">🟩 Positive</button>
        
            <label>NSFW:</label>
            <button class="filter-toggle-btn" id="nsfw-toggle" data-value="true">🔞 Allow NSFW</button>
        </div>
        

        <button class="new-notes-button" id="newNotesButton" onclick="showNewNotes()">Show 0 New Notes</button>

        <div class="fetch-status" id="fetchStatus">Searching...</div>
        <button id="scrollToTopBtn" class="scroll-top-btn" onclick="scrollToTop()">▲</button>

        <div id="notes">

        </div>
    </div>

    <div class="fullscreen" id="fullscreen">
        <img src="" alt="Full Image" id="fullImage">
    </div>

    <!-- Modal for Time Range Selection -->
    <div id="timeModal" class="modal">
        <div class="modal-content" id="modalContent">
            <span class="close" id="closeModal">&times;</span>
            <h4>Select Time Range</h4>
            <p id="selectedTimeRange">24h</p> <!--  Show current selection -->
            <input type="range" min="0" max="4" value="0" step="1" class="slider" id="timeRangeSlider">
            <div class="slider-labels">
                <span>24h</span>
                <span>Week</span>
                <span>Month</span>
                <span>Year</span>
                <span>🦕</span>
            </div>
        </div>
    </div>

    <div id="counters" display="none">
        <div id="matchesCounter">Fetching...</div>
    </div>

    <script>
        
const fallbackRelays = [
    "wss://relay.damus.io",
    "wss://nos.lol",
    // "wss://relay.snort.social",
    // "wss://relay.current.fyi",
    "wss://nostr.mom",
    // "wss://brb.io/",
    // "wss://freespeech.casa",
    "wss://relay.primal.net",
    "wss://purplepag.es"
];

const NIP50Relays = [
    "wss://rsrelay.235421.xyz/",
    // "wss://relay.roli.social", X
    "wss://bostr.bitcointxoko.com/",
    "wss://satellite.hzrd149.com/",
    "wss://poster.place/relay",
    "wss://relay.bostr.online/",
    "wss://relay.nostpy.lol/",
    "wss://social.protest.net/relay",
    "wss://bostr.lightningspore.com/",
    "wss://relay.nostr.band/",
    "wss://eclipse.pub/relay",
    "wss://ditto.pub/relay",
    "wss://relay.cxplay.org"
];


let profileCache = {}; // Store fetched profiles to avoid duplicates
const profileImageFailures = new Map();// Track profile image retry attempts per pubkey
const keywords = [""]; //default keyword
// Maintain keywords with their toggle state
let keywordStates = {}; // Maintain keywords with their toggle state. e.g., { dog: true, cat: true, potato: true }
let maxNotes = 100; // Default value, will adjust dynamically
let notes = [];
let fetchedNoteIds = new Set();
let newNotes = [];
let timeRange = 0; // Default is "Now"
let matchCount = 0;
// let activeRelays = 0;
let isInitialFetch = false; // Add this flag to track initial fetch state
let activeRelays = []; // Stores active relay names
let isFetching = false; // Prevents multiple fetches at once and Track ongoing searches
let activeWebSockets = new Map(); // Store active WebSocket connections
let abortController = new AbortController(); // Store controller to cancel searches
let requireAllKeywords = false; //  Default: Search for any keyword (OR mode)
let sentimentFilter = ""; // Store user-selected filters
let nsfwFilter = "true"; // Default is to allow NSFW


// Convert Unix timestamp to human-readable format
function formatTimestamp(timestamp) {
    const date = new Date(timestamp * 1000); // Convert to milliseconds
    return date.toLocaleString(); // Format date to readable format
}

// Scroll-to-top button logic
const scrollToTopBtn = document.getElementById("scrollToTopBtn");
const container = document.querySelector(".container");

// Track scroll inside the container
container.addEventListener("scroll", handleScroll);

// Handle scroll visibility within the container
function handleScroll() {
    if (container.scrollTop > 300) {
        scrollToTopBtn.style.display = "block";
    } else {
        scrollToTopBtn.style.display = "none";
    }
}

// Smooth scroll to top of the container
function scrollToTop() {
    container.scrollTo({
        top: 0,
        behavior: "smooth",
    });
}

// Observe dynamic content for changes
const notesContainer = document.getElementById("notes");

const observer = new MutationObserver(() => {
    handleScroll(); // Trigger scroll check when content changes
});

// Start observing the notes container for added nodes
observer.observe(notesContainer, { childList: true, subtree: true });

// Trigger visual feedback when fetching starts
function startFetching(relay = "") {
    const container = document.querySelector(".container");
    const fetchStatus = document.getElementById("fetchStatus");

    container.classList.remove("error", "success");
    container.classList.add("fetching");

    fetchStatus.style.display = "block"; 
    fetchStatus.style.color = "yellow";

    //  If relay is provided, add to active list
    if (relay && !activeRelays.includes(relay)) {
        activeRelays.push(relay);
    }

    //  Display all active relays
    fetchStatus.textContent = activeRelays.length > 0
        ? `Searching... \nActive Relays:\n ${activeRelays.join("\n")}`
        : "Searching...";
}

// Update the title dynamically
document.querySelector(".title").textContent = `${keywords}`;

// Stop fetching - Show success (Green glow)
function fetchingSuccess() {
    const container = document.querySelector(".container");
    const fetchStatus = document.getElementById("fetchStatus");

    container.classList.remove("fetching", "error");
    container.classList.add("success");
    fetchStatus.textContent = `Found ${matchCount} matches!`; // Display match count
    fetchStatus.style.color = "green"; // Update to green
    fetchStatus.style.display = "none"; // Hide "searching..."

    // Only hide counters if no matches were found
    if (matchCount === 0) {
        document.getElementById("counters").style.display = "none";
    }
}

let noMatchesShown = false;

function fetchingNoMatches() {
    if (noMatchesShown) return;
    noMatchesShown = true;

    const container = document.querySelector(".container");
    const fetchStatus = document.getElementById("fetchStatus");

    container.classList.remove("fetching", "success", "error");
    container.classList.add("fetching"); // Keep yellow border
    fetchStatus.textContent = "No matches found"; // Update message
    fetchStatus.style.color = "yellow"; // Ensure the text is yellow
    fetchStatus.style.display = "block"; // Ensure the status is visible

    console.warn("No matches found, stopping counter updates.");
    //  Hide counters when no matches exist
    updateCounters();
}

// Stop fetching - Show error (Red glow)
function fetchingError() {
    const container = document.querySelector(".container");
    const fetchStatus = document.getElementById("fetchStatus");

    container.classList.remove("fetching", "success");
    container.classList.add("error");
    fetchStatus.textContent =
        "Error: Failed to fetch data!\nCheck your internet connection"; // Update message
    fetchStatus.style.color = "red"; // Make it visually distinct
    fetchStatus.style.display = "block"; // Show error status
}

// Function to update the title dynamically with clickable keywords
function updateTitleWithKeywords() {
    const titleElement = document.querySelector(".title");
    const headTitleElement = document.querySelector("title"); // Select <title> in <head>

    if (keywords.length > 0) {
        const formattedKeywords = keywords
            .map((keyword) => {
                const isActive = keywordStates[keyword] ?? true; // Default to active if not set
                const spanClass = isActive
                    ? "keyword active"
                    : "keyword toggled";
                return `<span class="${spanClass}" onclick="toggleKeyword('${keyword}')">#${keyword}</span>`;
            })
            .join(" "); // Format keywords as clickable spans

        titleElement.innerHTML = formattedKeywords; // Update visible title
        headTitleElement.textContent = `${keywords.join(
            ", "
        )} | snofl discovery client`; // Update <title> in head
    } else {
        titleElement.textContent = "snofl discovery client"; // Default if no keywords
        headTitleElement.textContent = "snofl discovery client";
    }
}

// Function to toggle keyword state
function toggleKeyword(keyword) {
    keywordStates[keyword] = !keywordStates[keyword]; // Toggle the state
    updateTitleWithKeywords(); // Update styles in the title
    updateNotes(); // Filter results based on active keywords
}



// Trigger fetch when user searches
function triggerSearch() {
        resetCounters();
    //  Cancel previous search if it is still running
    if (abortController) {
        console.warn("⚠️ Canceling previous search...");
        abortController.abort();
    }

    abortController = new AbortController();
    const signal = abortController.signal;

    //  Close all previous WebSockets before new search
    activeWebSockets.forEach((ws, relay) => {
        console.warn(`⚠️ Closing WebSocket for ${relay} due to new search.`);
        ws.close();
    });
    activeWebSockets.clear(); //  Clear previous WebSocket connections


    const input = document.getElementById("keywordSearch").value.trim();

    if (!navigator.onLine) {
        console.error("No internet connection.");
        fetchingError(); // Trigger error status for no connection
        return;
    }

    // //  Cancel previous search if it is still running
    // if (isFetching && abortController) {
    //     console.warn("⚠️ Canceling previous search...");
    //     abortController.abort(); //  Stops previous search instantly
    // }

    //  Reset feed BEFORE fetching new results
    console.log("🚀 Clearing previous results before new search...");
    notes = [];
    newNotes = [];
    fetchedNoteIds.clear();

    //  Clear previous notes in UI immediately
    document.getElementById("notes").innerHTML = ""; // 🚀 This ensures old results disappear instantly!


    updateNotes();

    // Full reset logic
    matchCount = 0;
    // document.getElementById("matchesCounter").textContent = "M: 0";
    // document.getElementById("counters").style.display = "none";

    keywords.length = 0; // Clear the existing array
    keywordStates = {}; // Reset keyword toggle states
    keywords.forEach(keyword => {
        keywordStates[keyword] = true;
    });
    // isInitialFetch = true; // Set flag for initial fetch
    if (input) {
        keywords.push(...input.split(" ")); // Push keywords only if input exists

        // Initialize all keywords as active
        keywords.forEach((keyword) => {
            keywordStates[keyword] = true;
        });

        // console.log("Searching for keywords:", keywords);

        // Start fetching feedback
        startFetching();
        updateTitleWithKeywords(); // Update title dynamically

        // Handle fetch result with conditional status updates

        //  Start new search with fresh state
        fetchNotes(signal).then(() => {
            if (matchCount > 0) {
                fetchingSuccess();
                updateNotes();
            } else {
                fetchingNoMatches();
            }
        }).catch(() => fetchingError());
    } else {
        console.log("Empty input - not fetching.");
    }
}

document
    .getElementById("timeFilterButton")
    .addEventListener("click", openTimeModal);
document
    .getElementById("searchButton")
    .addEventListener("click", triggerSearch);

// Remove interval-based fetching if input is empty
document.getElementById("keywordSearch").addEventListener("input", (e) => {
    const input = e.target.value.trim();
    if (!input && interval) {
        clearInterval(interval);
        console.log("Stopped fetching due to empty input.");
    }
});

// Optional: Resume interval fetching after user input
document.getElementById("keywordSearch").addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
        triggerSearch();
    }
});

if (searchButton) {
    searchButton.addEventListener("click", () => {
        console.log("🔎 Search button clicked");
        triggerSearch();
    });
}


async function getOnlineRelays() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("r")) {
        console.log("🔄 Skipping online relay fetch because `r=` is set.");
        return decodeURIComponent(urlParams.get("r")).split(",");
    }

    try {
        const response = await fetch("https://api.nostr.watch/v1/nip/50");
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        
        const relays = await response.json();
        console.log("✅ Online relays fetched:", relays);

        return [...new Set([...relays, ...fallbackRelays])];
    } catch (error) {
        console.error("❌ Error fetching online relays:", error);
        console.log("Using fallback relays instead.");
        return fallbackRelays;
    }
}


function getRandomRelays(relays, num) {
    const shuffled = relays.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, num);
}



// Fetch profile metadata (kind 0 events) for the given notes.
// Opens parallel WebSocket connections to the fallback relays.
async function fetchProfilesForNotesParallel(notes) {
    // Gather all unique pubkeys that are not already in profileCache
    const pubkeysToFetch = notes
        .map(note => note.pubkey)
        .filter((pubkey, index, self) => pubkey && !profileCache[pubkey] && self.indexOf(pubkey) === index);

    if (pubkeysToFetch.length === 0) {
        console.warn("⚠️ No new pubkeys to fetch.");
        return;
    }

    console.log(`🔍 Fetching profiles in parallel for:`, pubkeysToFetch);

    //  Open parallel WebSocket connections to `fallbackRelays`
    const metadataFetches = fallbackRelays.map(relay => fetchMetadataFromRelay(relay, pubkeysToFetch));

    //  Run all metadata fetches concurrently
    await Promise.all(metadataFetches);
}

// Opens a WebSocket to a relay and requests profile metadata.
// Resolves when the connection is closed (or times out).
async function fetchMetadataFromRelay(relay, pubkeys) {
    return new Promise((resolve) => {
        try {
            const ws = new WebSocket(relay);
            
            ws.onopen = () => {
                console.log(`🌍 Requesting Kind 0 metadata from ${relay}`);
                // Build filter: kind 0 events from the pubkeys
                const filter = { kinds: [0], authors: pubkeys };
                ws.send(JSON.stringify(["REQ", "profile_fetch", filter]));
            };

            ws.onmessage = (event) => {
                console.log(`📩 Message received from ${relay}`);
                try {
                    const data = JSON.parse(event.data);
                    console.log("🛠 Raw WebSocket Data:", data);

                    // Only process valid "EVENT" messages with kind 0
                    if (data[0] !== "EVENT" || !data[2] || data[2].kind !== 0) {
                        console.warn(`⚠️ Skipping irrelevant WebSocket event from ${relay}:`, data);
                        return;
                    }

                    // Parse profile JSON from the event's content
                    const profile = JSON.parse(data[2].content);
                    profileCache[data[2].pubkey] = {
                        name: profile.name || "Unknown",
                        picture: profile.picture || "",
                        nip05: profile.nip05 || "",
                    };

                    console.log(`✅ Metadata stored for ${data[2].pubkey}:`, profileCache[data[2].pubkey]);

                    //  Immediately update UI after metadata is fetched
                    updateProfileInUI(data[2].pubkey);
                } catch (error) {
                    console.error(`❌ Error processing message from ${relay}:`, error);
                }
            };

            ws.onerror = (error) => {
                console.error(`❌ WebSocket error on ${relay}:`, error);
            };

            ws.onclose = () => {
                console.log(`🔌 WebSocket closed from ${relay}`);
                resolve(); //  Resolve the promise when WebSocket closes
            };

            //  Set a timeout to close WebSocket if no response
            setTimeout(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    console.warn(`⏳ Closing WebSocket due to timeout: ${relay}`);
                    ws.close();
                }
            }, 3000); // Close after 5 seconds

        } catch (error) {
            console.error(`❌ Failed to fetch metadata from ${relay}:`, error);
            resolve();
        }
    });
}

// Update the UI for a given pubkey.
function updateProfileInUI(pubkey) {
    const profile = profileCache[pubkey];

    if (!profile) {
        console.warn(`⚠️ No profile found for ${pubkey}, skipping update.`);
        return;
    }

    // console.log(`🔄 Updating UI for profile: ${pubkey}`);

    document.querySelectorAll(`.profile-img[data-pubkey="${pubkey}"]`).forEach(img => {
        if (profile.picture) {
            if (!profileImageFailures.has(pubkey)) {
                profileImageFailures.set(pubkey, 0);
            }

            let retryCount = profileImageFailures.get(pubkey);

            if (retryCount < 3) {
                img.src = profile.picture;
                img.onerror = () => {
                    retryCount++;
                    profileImageFailures.set(pubkey, retryCount);
                    console.warn(`🚨 Profile image failed (${retryCount}/3) for ${pubkey}: ${profile.picture}`);

                    if (retryCount >= 3) {
                        console.error(`❌ Stopping retries for ${pubkey}. Using fallback avatar.`);
                        img.src = `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${pubkey}`;
                        img.onerror = null; // Stop further retries
                    }
                };
            } else {
                console.warn(`🛑 Already failed 3 times for ${pubkey}. Using fallback avatar.`);
                img.src = `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${pubkey}`;
            }
        }
    });

    //  Update NIP-05 dynamically
    document.querySelectorAll(`.nip05[data-pubkey="${pubkey}"]`).forEach(nip05Element => {
        if (profile.nip05) {
            nip05Element.textContent = profile.nip05;
            console.log(`📛 NIP-05 updated for ${pubkey}: ${profile.nip05}`);
        }
    });
}





function truncateNip05(nip05) {
    if (nip05.length > 40) {
        const atIndex = nip05.indexOf("@");
        const domain = nip05.substring(atIndex);
        const truncated = `${nip05.substring(0, 10)}...${domain}`;
        return truncated;
    }
    return nip05;
}

// Map time ranges to maxNotes dynamically
const timeToMaxNotes = {
    // 0: 50000,  // Now - fewer notes
    0: 33333, // 24h
    1: 66666, // Week
    2: 111111, // Month
    3: 555555, // Year
    4: 1111111, // All time (🦕)
};

// Open the modal
function openTimeModal() {
    document.getElementById("timeModal").style.display = "block";
}

// Close the modal
function closeTimeModal() {
    document.getElementById("timeModal").style.display = "none";
}

/// Handle slider changes immediately (remove Apply button)
document.getElementById("timeRangeSlider").addEventListener("input", (e) => {
    timeRange = parseInt(e.target.value);
    maxNotes = timeToMaxNotes[timeRange];
    console.log(
        `Time range set to: ${getTimeRangeLabel(
            timeRange
        )}, maxNotes: ${maxNotes}`
    );

    //  Update the displayed time label
    document.getElementById("selectedTimeRange").textContent = getTimeRangeLabel(timeRange);

    const input = document.getElementById("keywordSearch").value.trim();
    if (input) {
        console.log("Time range set");
    } else {
        console.log("No input during time range change.");
    }
});

// Close modal when clicking outside or pressing the ❌ button
window.addEventListener("click", (e) => {
    const modal = document.getElementById("timeModal");
    const modalContent = document.getElementById("modalContent");

    if (e.target === modal || e.target.id === "closeModal") {
        closeTimeModal();
    }
});

// Get label for the selected time range
function getTimeRangeLabel(value) {
    const ranges = ["24h", "Week", "Month", "Year", "🦕"];
    return ranges[value];
}

// Calculate 'since' based on slider value
function calculateSinceTime(value) {
    const now = Math.floor(Date.now() / 1000);
    switch (value) {
        // case 0: return now;  // Now
        case 0:
            return now - 24 * 60 * 60; // 24 hours
        case 1:
            return now - 7 * 24 * 60 * 60; // Week
        case 2:
            return now - 30 * 24 * 60 * 60; // Month
        case 3:
            return now - 365 * 24 * 60 * 60; // Year
        case 4:
            return 0; // All time (🦕)
    }
}
// Kind 1: Note

function updateCounters() {
    const counters = document.getElementById("counters");
    const matchesCountText = document.getElementById("matchesCounter");

    //  Count only UNIQUE notes currently displayed in the feed
    const displayedNotesCount = notes.length;
    matchesCountText.textContent = `Matches: ${displayedNotesCount}`;

    //  Hide counter if no matches exist
    if (displayedNotesCount === 0) {
        counters.style.display = "none";
    } else {
        counters.style.display = "flex";
    }
}


function resetCounters() {
    matchCount = 0;
    updateCounters();
}


function updateFetchStatus() {
    const fetchStatus = document.getElementById("fetchStatus");

    if (activeRelays.length > 0) {
        fetchStatus.textContent = `Searching... \nActive Relays:\n ${activeRelays.join("\n")}`;
    } else {
        fetchStatus.textContent = "✅ Search completed.";
        document.querySelector(".container").classList.remove("fetching");
    }
}


function updateNewNotesButton() {
    //  Filter only unique notes that are NOT already in the feed
    const uniqueNewNotes = newNotes.filter(n => !notes.some(existingNote => existingNote.id === n.id));

    // console.log(`🆕 "New Notes" Button Updated: ${uniqueNewNotes.length} notes ready to be added.`);

    if (uniqueNewNotes.length > 0) {
        document.getElementById("newNotesButton").textContent = `Show ${uniqueNewNotes.length} New Notes`;
        document.getElementById("newNotesButton").style.display = "block";
    } else {
        document.getElementById("newNotesButton").style.display = "none"; //  Hide if no valid new notes
    }
}






let sortOrder = "desc"; // Default to 'newest first'

// Toggle the sorting order and re-render notes
function toggleSort() {
    sortOrder = sortOrder === "desc" ? "asc" : "desc";
    document.getElementById("sortButton").textContent = `Sort: ${
        sortOrder === "desc" ? "Newest" : "Oldest"
    }`;
    sortNotes();
    updateNotes();
}

// Sort notes based on timestamp
function sortNotes() {
    notes.sort((a, b) => {
        if (sortOrder === "desc") {
            return b.created_at - a.created_at; // Newest first
        } else {
            return a.created_at - b.created_at; // Oldest first
        }
    });
}

function noteMatchesKeywords(content, activeKeywords) {
    return requireAllKeywords
        ? activeKeywords.every(keyword => new RegExp(`\\b${keyword}\\b`, "gi").test(content)) //  AND mode (ALL keywords must match)
        : activeKeywords.some(keyword => new RegExp(`\\b${keyword}\\b`, "gi").test(content));  //  OR mode (ANY keyword can match)
}


async function fetchNotes() {
    if (isFetching) {
        console.log("⚠️ Fetch already in progress. Skipping...");
        abortController.abort();
    }
    abortController = new AbortController();
    isFetching = true;

    console.log("🚀 Clearing previous results before new search...");
    
    //  Ensure UI is cleared before fetching new notes
    notes = [];
    newNotes = [];
    fetchedNoteIds.clear();
    updateNotes();
    updateCounters();

    const searchQuery = document.getElementById("keywordSearch").value.trim();
    if (!searchQuery && keywords.length === 0) {
        console.error("❌ No keywords available for search. Stopping fetch.");
        isFetching = false;
        return;
    }

    console.log("🔍 Searching with keywords:", keywords);
    matchCount = 0;
    document.getElementById("matchesCounter").textContent = `Fetching...`;

    const urlParams = new URLSearchParams(window.location.search);
    let selectedRelays = [];

    if (urlParams.has("r")) {
        //  Use only relays from `r=` parameter
        selectedRelays = decodeURIComponent(urlParams.get("r")).split(",");
        console.log("✅ Using custom relays from URL:", selectedRelays);
    } else {
        //  Use random relays if `r=` is not set
        selectedRelays = getRandomRelays(NIP50Relays, 15);
        console.log("🔍 Selected random NIP-50 relays:", selectedRelays);
    }

    if (selectedRelays.length === 0) {
        console.error("❌ No relays available. Cannot proceed.");
        fetchingError();
        isFetching = false;
        return;
    }

    console.log("🚀 Starting search on relays:", selectedRelays);

    const filter = {
        // search: searchQuery,
        kinds: [1],
        limit: maxNotes,
        since: calculateSinceTime(timeRange), //  Apply time filter dynamically
    };

    // When in AND mode, pass the search query to the relay.
    // When in OR mode, omit it so the relay doesn’t pre-filter the results.
    if (requireAllKeywords && searchQuery) {
        filter.search = searchQuery;
    }

    startFetching();

    //  Fetch notes & metadata in parallel
    const fetchPromises = selectedRelays.map(async (relay) => {
        try {
            const ws = new WebSocket(relay);
            activeWebSockets.set(relay, ws); // Track active WebSocket
            let resultsReceived = false;
            let receivedCount = 0;
            let matchedCount = 0;

            console.log(`🌍 Connecting to ${relay}`);

            ws.onopen = () => {
                console.log(`✅ Connected to ${relay}, sending search request.`);
                ws.send(JSON.stringify(["REQ", "nip50_search", filter]));
            };

            ws.onmessage = (event) => {
                if (abortController.signal.aborted) {
                    console.warn(`⚠️ Fetch aborted. Closing WebSocket for ${relay}`);
                    ws.close();
                    return;
                }

                const data = JSON.parse(event.data);
                if (!data || data.length < 3 || data[0] !== "EVENT") return;

                const note = data[2];
                const noteId = note.id;
                receivedCount++;

                //  Ignore banned profiles
                const bannedProfiles = JSON.parse(localStorage.getItem("clientBannedProfiles")) || [];
                if (bannedProfiles.includes(note.pubkey)) {
                    console.warn(`🚫 Ignoring note from banned profile: ${note.pubkey}`);
                    return;
                }

                if (!fetchedNoteIds.has(noteId) && !notes.some(n => n.id === noteId) && !newNotes.some(n => n.id === noteId)) {
                    fetchedNoteIds.add(noteId);

                    if (!note.content) {
                        console.warn(`⚠️ Note is missing content. Skipping.`);
                        return;
                    }

                    //  Check if the note matches the search keywords
                    const content = note.content.toLowerCase();
                    const activeKeywords = Object.keys(keywordStates).filter(k => keywordStates[k]);

                    if (activeKeywords.length === 0) {
                        console.warn("⚠️ No active keywords! Search cannot work.");
                        return;
                    }

                    //  Apply AND/OR logic
                    const isMatch = requireAllKeywords
                        ? activeKeywords.every(keyword => new RegExp(`\\b${keyword}\\b`, "gi").test(content)) // AND Mode
                        : activeKeywords.some(keyword => new RegExp(`\\b${keyword}\\b`, "gi").test(content)); // OR Mode

                    if (isMatch) {
                        matchedCount++;

                        if (selectedRelays[0] === relay) {
                            //  Show first relay's matches immediately in feed
                            notes.push(note);
                            updateNotes();
                            fetchProfilesForNotesParallel(notes);
                            updateCounters();
                        } else {
                            //  Store other relay results in "New Notes"
                            newNotes.push(note);
                            updateNewNotesButton();
                        }

                        resultsReceived = true;
                        updateNotes();
                        fetchProfilesForNotesParallel(notes);
                        updateCounters();
                    }
                }
            };

            ws.onclose = () => {
                console.warn(`❌ Disconnected from ${relay}`);
                activeWebSockets.delete(relay);

                console.log(`📊 Relay: ${relay}`);
                console.log(`📩 Total notes received: ${receivedCount}`);
                console.log(`✅ Total matching notes: ${matchedCount}`);
                console.log(`🆕 "New Notes" stored: ${newNotes.length}`);
                console.log(`📢 Notes currently displayed: ${notes.length}`);
                console.log(`🎯 Expected "Matches" Counter: ${notes.length}`);

                activeRelays = activeRelays.filter(r => r !== relay.replace("wss://", "").replace("/", ""));
                updateFetchStatus();
            };

            ws.onerror = (error) => {
                console.error(`⚠️ Connection error on ${relay}:`, error);
                activeWebSockets.delete(relay);
                activeRelays = activeRelays.filter(r => r !== relay.replace("wss://", "").replace("/", ""));
                updateFetchStatus();
            };

            setTimeout(() => {
                if (resultsReceived && ws.readyState === WebSocket.OPEN) {
                    console.log(`Closing WebSocket after receiving results from ${relay}`);
                    ws.close();
                }
            }, 5000);

            setTimeout(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    console.warn(`Closing WebSocket due to timeout: ${relay}`);
                    ws.close();
                }
            }, 8000);
        } catch (error) {
            console.error(`❌ Failed to fetch from relay: ${relay}`, error);
        }
    });

    await Promise.all(fetchPromises);

    console.log(`✅ Search complete. Fetched ${newNotes.length} new notes.`);
    if (matchCount > 0) {
        fetchingSuccess();
        updateNewNotesButton();
    } else {
        fetchingNoMatches();
    }

    // ✅ Fetch metadata for all pubkeys in notes
    await fetchProfilesForNotesParallel(notes);
    updateCounters();
    sortNotes();
    updateNotes();

    isFetching = false;
}

let interval;

// Helper function to shorten pubkey (e.g., abc1...def9)
function shortenPubKey(pubkey) {
    if (pubkey.length > 8) {
        return `${pubkey.slice(0, 4)}...${pubkey.slice(-4)}`;
    }
    return pubkey; // Return full key if it's unusually short
}

// 1. Highlight Keywords and URLs
function highlightContent(content) {
    // Highlight https:// links (clickable, dark blue)
    content = content.replace(/https:\/\/\S+/gi, (match) => {
        let highlightedLink = match;
        // Highlight keyword inside the link
        keywords.forEach((keyword) => {
            const regex = new RegExp(`(${keyword})`, "gi");
            highlightedLink = highlightedLink.replace(
                regex,
                '<span style="color: blue;">$1</span>'
            );
        });

        return `<a href="${match}" target="_blank" style="color: darkblue; text-decoration: underline;">${highlightedLink}</a>`;
    });

    // Highlight http:// links (non-clickable, grey)
    content = content.replace(/http:\/\/\S+/gi, (match) => {
        let highlightedText = match;
        keywords.forEach((keyword) => {
            const regex = new RegExp(`(${keyword})`, "gi");
            highlightedText = highlightedText.replace(
                regex,
                '<span style="color: blue;">$1</span>'
            );
        });

        return `<span style="color: grey;">${highlightedText}</span>`;
    });

    // Highlight hashtags #keyword (green, bold)
    keywords.forEach((keyword) => {
        const hashtagRegex = new RegExp(`#(${keyword})\\b`, "gi");
        content = content.replace(
            hashtagRegex,
            '<span class="hashtag">#$1</span>'
        );
    });

    // Highlight regular keywords (not inside links or hashtags) in purple
    keywords.forEach((keyword) => {
        const normalRegex = new RegExp(
            `(?<![/])(?<!https:|http:)\\b(${keyword})\\b`,
            "gi"
        );
        content = content.replace(
            normalRegex,
            '<span class="highlight">$1</span>'
        );
    });

    return content;
}


function updateNotes() {
    const notesContainer = document.getElementById("notes");

    //  Ensure feed is never empty when notes exist
    if (notes.length === 0) {
        console.warn("⚠️ No notes available to display!");
        return;
    }

    // Filter notes based on active keywords
    const activeKeywords = Object.keys(keywordStates).filter(
        (k) => keywordStates[k]
    );

    const filteredNotes = notes.filter((note) => {
        const content = note.content.toLowerCase();
        if (requireAllKeywords) {
        // AND logic: every active keyword must match
        return activeKeywords.every(keyword =>
            new RegExp(`\\b${keyword}\\b`, "gi").test(content)
        );
        } else {
        // OR logic: at least one active keyword must match
        return activeKeywords.some(keyword =>
            new RegExp(`\\b${keyword}\\b`, "gi").test(content)
        );
        }

        // if (!isActive) return false;

            // Regex to match only whole words, not inside other words
            const wordBoundaryRegex = new RegExp(`\\b${keyword}\\b`, "gi");
            return wordBoundaryRegex.test(content);

    });

    // Render all notes (hide notes with only toggled-off keywords)
    notesContainer.innerHTML = filteredNotes
        .map((note) => {
            const profile = profileCache[note.pubkey] || {}; // Fetch profile from cache if available

            // Ensure profile picture updates dynamically when metadata arrives
            const avatarUrl = profile.picture
                ? profile.picture // Use real profile picture if available
                : `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${note.pubkey}`; // Otherwise, use fallback avatar

            //  Correct NIP-05 Fallback (Show Shortened Pubkey if Missing)
            const nip05Display = profile.nip05
                ? `<div class="nip05">${truncateNip05(profile.nip05)}</div>`
                : `<div class="nip05">${shortenPubKey(note.pubkey)}</div>`; //  Show pubkey instead of "Fetching..."

            // Format timestamp
            const readableTime = formatTimestamp(note.created_at || Date.now() / 1000);
            const noteIdShort = `${note.id.slice(0, 4)}...${note.id.slice(-4)}`;

            // Highlight keywords and hashtags
            let highlightedContent = note.content;

            keywords.forEach((keyword) => {
                const isActive = keywordStates[keyword] ?? true; // Check toggle state
                const style = isActive ? "highlight" : "inactive";

                // Highlight hashtags with full words (e.g., #keyword) in green
                const hashtagRegex = new RegExp(`#(${keyword})\\b`, "gi");
                highlightedContent = highlightedContent.replace(
                    hashtagRegex,
                    `<span class="${
                        isActive ? "hashtag" : "inactive"
                    }">#$1</span>`
                );

                // Highlight regular keywords not part of hashtags in purple or inactive gray
                const normalRegex = new RegExp(
                    `(?<!#)\\b(${keyword})\\b`,
                    "gi"
                ); // Ignore matches preceded by #
                highlightedContent = highlightedContent.replace(
                    normalRegex,
                    `<span class="${style}">$1</span>`
                );
            });

            // Ensure image click opens in fullscreen
            const imageRegex = /(https?:\/\/\S+\.(?:jpg|jpeg|gif|png|webp))/gi;
            highlightedContent = highlightedContent.replace(
                imageRegex,
                (match) =>
                    `<img src="${match}" alt="Image" class="note-image">`
            );

            // Determine visibility of the note
            const noteContent = note.content.toLowerCase();
            const hasOnlyToggledKeywords = keywords.every(
                (keyword) =>
                    noteContent.includes(keyword.toLowerCase()) &&
                    !keywordStates[keyword]
            );
            const visibilityStyle = hasOnlyToggledKeywords
                ? "display: none;"
                : "";

            // Apply `truncated` class if the note is longer than 300 characters
            const isTruncated = highlightedContent.length > 300;
            const truncatedClass = isTruncated ? "truncated" : "";

            const isHidden = hiddenNotes.has(note.id) ? "hidden" : ""; // Check if note should be hidden

            return `
        <div class="note ${hiddenNotes.has(note.id) ? "hidden" : ""}" style="${visibilityStyle}">
            <!--  Eye Button: Above Metadata & Copy Button -->
            <button class="hide-eye-button" onclick="toggleHide('${note.id}')" title="Hide/Show Note">
                <img src="${hiddenNotes.has(note.id) ? "img/othrIcon/eye_hide.png" : "img/othrIcon/eye_view.png"}" alt="Toggle Visibility">
            </button>

            <button class="ban-profile-button" onclick="banProfile('${note.pubkey}')" style="display: none;" title="Nuke this Profile">
                <img src="img/othrIcon/bomb.png" alt="Ban Profile">
            </button>

            <button class="copy-button" data-noteid="${note.id}" title="Copy Note ID">
                <img src="https://img.icons8.com/material-outlined/24/000000/copy.png" alt="Copy Icon">
            </button>
            <div class="note-header">
                <img src="${avatarUrl}" 
                    alt="User Image" 
                    class="profile-img" 
                    data-pubkey="${note.pubkey}"
                    onload="this.classList.add('loaded')"
                    onerror="this.src='${avatarUrl}'; this.classList.add('loaded')">
                <div>
                    <span>${profile.name || shortenPubKey(note.pubkey)}</span>
                    ${nip05Display}  <!--  Ensuring NIP-05 or Pubkey as fallback -->
                </div>
            </div>
            <div class="note-content ${truncatedClass}" data-note-id="${note.id}">
                ${highlightedContent}
                ${isTruncated ? `<div class="expand-note" onclick="toggleNoteExpansion('${note.id}')">...more</div>` : ""}
            </div>

            <div class="collapsed-note" data-note-id="${note.id}">
                -------------------- ${noteIdShort}> --------------------
            </div>

        <!-- Icons and timestamp container -->
        <div class="note-footer">
            <div class="note-icons">
                <span class="icon" title="Thumbs Up" onclick="handleIconClick('upvote', '${
                    note.id
                }')">👍</span>
                <!-- <span class="icon" title="Thumbs Down" onclick="handleIconClick('downvote', '${
                    note.id
                }')">👎</span> -->
                <span class="icon" title="Repost" onclick="handleIconClick('repost', '${
                    note.id
                }')">🔁</span>
                <span class="icon" title="Reply" onclick="handleIconClick('reply', '${
                    note.id
                }')">💬</span>
            </div>
            <div class="note-timestamp">
                ${readableTime}
            </div>
        </div>
    </div>
    `;
        })
        .join("");
        // console.log("✅ Feed updated with new notes.");

            //  Ensure profile pictures update when metadata arrives
        notes.forEach(note => {
            updateProfileInUI(note.pubkey);
        });

        // Reattach click listeners after notes are rendered
        attachProfileImageClickListeners();

        // Attach event listener for copy buttons
        attachCopyListeners();
        attachImageClickListeners(); // Attach image event listeners every time updateNotes() runs
}

let hiddenNotes = new Set(JSON.parse(localStorage.getItem("hiddenNotes") || "[]")); //  Load stored hidden notes

function toggleHide(noteId) {
    const noteElement = document.querySelector(`.note-content[data-note-id="${noteId}"]`).parentElement;
    const noteHeader = noteElement.querySelector(".note-header"); //  Select metadata
    const eyeButton = noteElement.querySelector(".hide-eye-button img"); //  Select eye icon
    const bombButton = noteElement.querySelector(".ban-profile-button"); // Bomb icon

    if (hiddenNotes.has(noteId)) {
        hiddenNotes.delete(noteId); //  Remove from hidden state
        localStorage.setItem("hiddenNotes", JSON.stringify([...hiddenNotes])); //  Save updated hidden notes list
        noteElement.classList.remove("hidden");
        if (noteHeader) noteHeader.style.display = "flex"; //  Show metadata
        eyeButton.src = "img/othrIcon/eye_view.png"; //  Change to "view" icon
        if (bombButton) bombButton.style.display = "none"; // Hide bomb icon
    } else {
        hiddenNotes.add(noteId); //  Mark as hidden
        localStorage.setItem("hiddenNotes", JSON.stringify([...hiddenNotes])); //  Save updated hidden notes list
        noteElement.classList.add("hidden");
        if (noteHeader) noteHeader.style.display = "none"; //  Hide metadata
        eyeButton.src = "img/othrIcon/eye_hide.png"; //  Change to "hide" icon
        if (bombButton) bombButton.style.display = "block"; // Show bomb icon
    }
}

function banProfile(pubkey) {
    console.log(`💣 Banning profile: ${pubkey}`);

    // Load existing banned profiles from localStorage
    let bannedProfiles = JSON.parse(localStorage.getItem("clientBannedProfiles")) || [];

    // Only add if not already banned
    if (!bannedProfiles.includes(pubkey)) {
        bannedProfiles.push(pubkey);
        localStorage.setItem("clientBannedProfiles", JSON.stringify(bannedProfiles));
    }

    // Remove all notes from this profile from the feed
    const removedNotes = notes.filter(note => note.pubkey === pubkey).length;
    notes = notes.filter(note => note.pubkey !== pubkey);
    updateNotes(); // Refresh feed

    // Update match counter
    matchCount -= removedNotes;
    updateCounters();

    console.log(` Removed ${removedNotes} notes from banned profile: ${pubkey}`);
}


function toggleNoteExpansion(noteId) {
    const noteContent = document.querySelector(`.note-content[data-note-id="${noteId}"]`);

    if (noteContent.classList.contains("truncated")) {
        noteContent.classList.remove("truncated"); // Expand note
        noteContent.querySelector(".expand-note").textContent = "...less";
    } else {
        noteContent.classList.add("truncated"); // Collapse note
        noteContent.querySelector(".expand-note").textContent = "...more";
    }
}

// Function to attach event listeners for copy buttons
function attachCopyListeners() {
    document.querySelectorAll(".copy-button").forEach(button => {
        button.addEventListener("click", function () {
            const noteId = this.dataset.noteid; //  Retrieve `data-noteid` properly

            if (!noteId) {
                console.error("❌ Error: Note ID is missing!");
                alert("Error: Could not copy Note ID.");
                return;
            }

            copyToClipboard(noteId);
        });
    });
}


function attachProfileImageClickListeners() {
    document.querySelectorAll(".profile-img").forEach((img) => {
        img.removeEventListener("click", handleProfileImageClick); //  Prevent duplicate listeners
        img.addEventListener("click", handleProfileImageClick);
    });
}

function handleProfileImageClick(event) {
    const pubkey = event.target.getAttribute("data-pubkey");
    if (pubkey) {
        console.log(`🔗 Opening profile: https://nosta.me/${pubkey}`);
        window.open(`https://nosta.me/${pubkey}`, "_blank");
    }
}

// Track image retry attempts
const imageRetries = new Map();

// Function to retry loading images up to 3 times
function handleImageError(img) {
    const originalSrc = img.dataset.originalSrc || img.src;

    // Store the original src if not already stored
    if (!img.dataset.originalSrc) {
        img.dataset.originalSrc = originalSrc;
    }

    // Initialize retry count if not present
    if (!imageRetries.has(originalSrc)) {
        imageRetries.set(originalSrc, 0);
    }

    let retryCount = imageRetries.get(originalSrc);

    if (retryCount < 3) {
        console.warn(`Retrying image: ${originalSrc} (Attempt ${retryCount + 1}/3)`);
        imageRetries.set(originalSrc, retryCount + 1);

        // Apply a low-opacity blur effect while retrying
        img.style.filter = "blur(5px)";
        img.style.opacity = "0.5";

        // Create a temporary new image to check if the source is valid before applying
        const tempImg = new Image();
        tempImg.src = originalSrc + "?retry=" + Date.now();
        tempImg.onload = function () {
            // Remove blur & opacity when successfully loaded
            img.style.filter = "";
            img.style.opacity = "1";
            img.src = tempImg.src; // Update source only after confirming it's valid
        };
        
        tempImg.onerror = function () {
            console.error(`Image retry failed: ${originalSrc} (Attempt ${retryCount + 1}/3)`);
        };
    } else {
        console.error(`Failed to load image after 3 attempts: ${originalSrc}`);
        img.src = "https://via.placeholder.com/150?text=Image+Unavailable"; // Placeholder
        img.style.filter = ""; // Reset styles
        img.style.opacity = "1";
        img.onerror = null; // Prevent infinite loop
    }
}

// Avoid duplicate event listeners
let isObserving = false;

// Attach error handling to all dynamically loaded images
function monitorImages() {
    document.querySelectorAll(".note-content img").forEach((img) => {
        if (!img.dataset.errorHandler) {
            img.dataset.errorHandler = "true"; // Mark as processed
            img.onerror = function () {
                handleImageError(this);
            };
        }
    });
}

// Observe only once
if (!isObserving) {
    const observer = new MutationObserver(() => {
        monitorImages();
    });

    observer.observe(document.getElementById("notes"), { childList: true, subtree: true });
    isObserving = true;
}

function attachImageClickListeners() {
    const images = document.querySelectorAll(".note-image");
    images.forEach((img) => {
        img.addEventListener("click", () => {
            const fullScreenContainer = document.getElementById("fullscreen");
            const fullImage = document.getElementById("fullImage");
            fullImage.src = img.src;
            fullScreenContainer.classList.add("active");
        });
    });
}

// Ensure clicking outside the image closes fullscreen
document.getElementById("fullscreen").addEventListener("click", (event) => {
    const fullScreenContainer = document.getElementById("fullscreen");
    if (event.target === fullScreenContainer) {
        fullScreenContainer.classList.remove("active");
    }
});


// Show new notes when the button is clicked
function showNewNotes() {
    if (newNotes.length === 0) {
        console.warn("⚠️ No new notes to show!");
        return;
    }

    //  Merge only UNIQUE new notes into the feed
    const uniqueNewNotes = newNotes.filter(n => !notes.some(existingNote => existingNote.id === n.id));
    notes = [...uniqueNewNotes, ...notes];

    console.log(`📢 Added ${uniqueNewNotes.length} new notes to the feed.`);
    console.log(`📊 Total notes now in feed: ${notes.length}`);

    //  Clear new notes array
    newNotes = [];

    //  Refresh the UI
    sortNotes();
    updateNotes();
    fetchProfilesForNotesParallel(notes);
    updateNewNotesButton();
    updateCounters();
}




// Attach event listener for the "New Notes" button
document.getElementById("newNotesButton").addEventListener("click", showNewNotes);


function copyToClipboard(noteId) {
    if (!noteId || noteId === "null") {
        console.error("❌ Error: Trying to copy an invalid Note ID.");
        alert("Error: Invalid Note ID. Copy failed.");
        return;
    }

    navigator.clipboard
        .writeText(noteId)
        .then(() => {
            console.log(`✅ Note ID copied: ${noteId}`);
            alert(`Note ID: ${noteId} \nCopied to clipboard`);
        })
        .catch((err) => {
            console.error("❌ Failed to copy: ", err);
            alert("Error: Could not copy Note ID.");
        });
}


document.getElementById("fullscreen").addEventListener("click", () => {
    const fullScreenContainer = document.getElementById("fullscreen");
    fullScreenContainer.classList.remove("active");
});

// Handle icon click actions (for now just logging) It will be a future feature for reposting, replies and reactions.
function handleIconClick(action, noteId) {
    console.log(`${action} clicked for note: ${noteId}`);
}

document.getElementById("magnetButton").addEventListener("click", function () {
    requireAllKeywords = !requireAllKeywords; // Toggle AND/OR mode

    //  Ensure proper class toggling
    if (requireAllKeywords) {
        this.classList.add("active");  // Force Green (AND Mode)
    } else {
        this.classList.remove("active"); // Force Grey (OR Mode)
    }

    // Clear the feed data:
    notes = [];
    newNotes = [];
    fetchedNoteIds.clear();

    // Clear the feed UI.
    document.getElementById("notes").innerHTML = "";
    updateCounters();

        //  Force a search refresh when toggling the Magnet button
    if (!isFetching) {
        console.log("🚀 Magnet mode changed, triggering a fresh search...");
        fetchNotes(); // 🔄 Ensures the search actually updates to OR when toggled OFF
    } else {
        console.warn("⚠️ Fetch already in progress. Skipping...");
    }

    console.log(`🧲 Magnet Mode: ${requireAllKeywords ? "ON (AND Search)" : "OFF (OR Search)"}`);

    //  Check if `h=` exists in the URL
    const urlParams = new URLSearchParams(window.location.search);
    const hasSearchParams = urlParams.has("h");

    //  Check if the user has manually typed something
    const inputBox = document.getElementById("keywordSearch");
    const inputNotEmpty = inputBox.value.trim() !== "";

    // 🔄 If `h=` exists but no manual input, trigger an immediate search
    if (hasSearchParams && !inputNotEmpty) {
        console.log("🔎 Re-triggering search due to Magnet Mode change (from `h=` parameters)...");
        if (!isFetching) {
            console.log("🚀 Triggering search...");
            fetchNotes();
        } else {
            console.warn("⚠️ Fetch already in progress. Skipping...");
        }
    }
});


// Toggle button behavior for filters (Sentiment, NSFW)
document.querySelectorAll(".filter-toggle-btn").forEach(btn => {
    btn.addEventListener("click", function () {
        // Toggle active state
        this.classList.toggle("active");

        // Set values based on selection
        if (this.id.startsWith("sentiment")) {
            // Remove active state from other sentiment buttons
            document.querySelectorAll(".toggle-btn[id^='sentiment']").forEach((b) => {
                if (b !== this) b.classList.remove("active");
            });

            // Update sentiment filter
            sentimentFilter = this.classList.contains("active") ? this.dataset.value : "";
            console.log(`Sentiment Filter Set: ${sentimentFilter}`);
        }

        if (this.id === "nsfw-toggle") {
            // Toggle NSFW filter
            nsfwFilter = this.classList.contains("active") ? "false" : "true";
            console.log(`NSFW Filter Set: ${nsfwFilter}`);
        }

        console.log("Filters Updated:", { sentimentFilter, nsfwFilter });
    });
});

// Auto-fetch keywords and relays from URL and trigger search on page load
window.addEventListener("DOMContentLoaded", () => {
    const urlParams = new URLSearchParams(window.location.search);
    const keywordsFromURL = urlParams.get("h") || ""; //  Get `h=` parameter
    console.log("🌍 Extracted Keywords from URL:", keywordsFromURL);
    const relaysFromURL = urlParams.get("r"); // Get 'r' parameter (relays)
    const magnetButton = document.getElementById("magnetButton");
    // Reset keywords array properly
    keywords.length = 0;

    if (keywordsFromURL) {

        console.log("🔄 `h=` detected, setting search mode to AND (ALL keywords required).");
        requireAllKeywords = true; //  Start in AND mode
        magnetButton.classList.add("active");  //  Ensure Green
        
        // Decode, remove hashtags (#), and replace commas with spaces
        let keywordArray = decodeURIComponent(keywordsFromURL)
            .replace(/%23/g, '')  // Remove encoded `#`
            .replace(/#/g, '')  // Remove any remaining `#`
            .replace(/,/g, ' ')  // Replace commas with spaces
            .split(/\s+/); // Split by spaces

        // Ensure we only add valid keywords
        if (keywordArray.length > 0 && keywordArray[0] !== "") {
            document.getElementById("keywordSearch").value = keywordArray.join(" ");

            //  Reset `keywords` to ensure it's fresh
            keywords.length = 0;
            keywords.push(...keywordArray);

            //  Ensure all keywords are active
            keywordStates = {};
            keywords.forEach(keyword => {
                keywordStates[keyword] = true;
            });

            console.log("✅ Keywords Loaded for Search:", keywords);
        } else {
            console.warn("⚠️ No valid keywords found in URL.");
        }
    //  If `h=` is present, trigger a search with AND mode
    if (keywords.length > 0) {
    console.log("🔄 `h=` detected, starting search in AND mode...");
    if (!isFetching) {
        console.log("🚀 Triggering search...");
        fetchNotes();
    } else {
        console.warn("⚠️ Fetch already in progress. Skipping...");
    }
    }

    else {
        //  If no `h=`, start in OR mode by default
        requireAllKeywords = false; //  Default to OR mode
        magnetButton.classList.remove("active"); //  Ensure Grey
    }
    }


//  Load relays if available
if (relaysFromURL) {
    const relayArray = decodeURIComponent(relaysFromURL).split(",");
    if (relayArray.length > 0 && relayArray[0] !== "") {
        fallbackRelays.length = 0;
        fallbackRelays.push(...relayArray);
        console.log("🔄 Using custom relays:", fallbackRelays);
    }
}

    // Only trigger search if valid keywords were found
    if (keywords.length > 0) {
        // Set max history (full slider)
        timeRange = 4; // Set slider to 'All Time'
        maxNotes = timeToMaxNotes[timeRange]; // Update max notes based on slider

        // Adjust the slider visually
        document.getElementById("timeRangeSlider").value = 4;

        updateTitleWithKeywords();
        startFetching();

        fetchNotes()
            .then(() => fetchingSuccess())
            .catch(() => fetchingError());
    } else {
        console.log("No keywords provided, waiting for user input.");
    }
});
</script>
</body>
</html>