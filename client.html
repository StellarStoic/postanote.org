<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Keywords Searcher</title>

    <!-- Favicon for most browsers -->
    <link rel="icon" href="/img/favicon_io/favicon.ico" type="image/x-icon">
    
    <!-- PNG icons for better resolution -->
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png">
    
    <!-- Apple Touch Icon (for iOS) -->
    <link rel="apple-touch-icon" href="/img/favicon_io/apple-touch-icon.png">
    
    <!-- Web Manifest (for PWAs) -->
    <link rel="manifest" href="/img/favicon_io/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>snofl discovery client</title>
    <style>
        @import url(https://fonts.bunny.net/css?family=athiti:200);
        /* Root font-size scaling based on viewport width */
        html {
            font-size: calc(1vw + 1vh + 0.5vmin); /* Adjusts base font size based on the viewport */
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Athiti', sans-serif;
            background-color: black;
            color: rgb(255, 255, 255);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            width: 99vw;
            max-width: 800px;
            height: 100vh;
            overflow-y: scroll;
            scrollbar-width: none;  /* For Firefox */
            -ms-overflow-style: none;  /* For Internet Explorer/Edge */
            border: 1px solid transparent;  /* Default no border */
            transition: border-color 0.3s, box-shadow 0.3s;  /* Smooth transitions */
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }

        .container::-webkit-scrollbar {
            display: none;  /* For Chrome, Safari, and Opera */
        }

        .fetch-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: yellow;
            display: none;  /* Hidden by default */
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        .container.fetching {
            border-color: yellow;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);  /* Glowing yellow border */
        }

        .container.success {
            border-color: green;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);  /* Green glow when successful */
        }

        .container.error {
            border-color: red;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);  /* Red glow on error */
}

        .note {
            background-color: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            position: relative;
        }

        .highlight {
            font-weight: bold;
            color: rgb(216, 101, 255);
        }

        .hashtag {
            font-weight: bold;
            color: rgb(46, 233, 46);
        }

        .note-header {
            display: flex;
            align-items: flex-start;
            margin-bottom: 5px;
        }
        .note-header img {
            width: 30px;
            height: 30px;
            border-radius: 3px;
            margin-right: 10px;
        }
        .note-content {
            word-wrap: break-word;
            margin-top: 10px;
            text-align: left;
        }
        .title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1rem;
        }
        .nip05 {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 40px;
        }

        .profile-img:hover {
            cursor: pointer;
            opacity: 0.8;
        }

        .note-content img {
            max-width: 100px;
            max-height: 100px;
            cursor: pointer;
            margin-top: 10px;
        }
        .fullscreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .fullscreen img {
            max-width: 90%;
            max-height: 90%;
        }
        .fullscreen.active {
            display: flex;
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: green;
        }
        .copy-button img {
            width: 20px;
            height: 20px;
        }
        .new-notes-button {
            position: sticky;
            top: 7px;
            right: 13px;
            background-color: green;
            color: black;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 99999;
            display: none;
        }

        .note-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .note-icons {
            display: flex;
            gap: 15px;
            font-size: 0.5rem;
        }

        .icon:hover {
            cursor: pointer;
            opacity: 0.7;
        }

        .note-timestamp {
            font-size: 0.5rem;
            color: #aaa;
            text-align: right;
        }

        .keyword {
            margin: 0 5px;
            cursor: pointer;
            border-bottom: 1px dashed transparent;
            transition: all 0.3s ease;
        }

        .keyword.active {
            color: green;
            font-weight: bold;
            border-bottom: 1px dashed green;
        }

        .keyword.toggled {
            color: red;
            font-style: italic;
            border-bottom: 1px dashed red;
        }

        .highlight {
            color: purple;
            font-weight: bold;
        }

        .inactive {
            color: gray;
            font-style: italic;
        }


        .search-bar {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .search-bar input {
            width: 60%;
            padding: 10px;
            font-size: 1rem;
            border: 1px solid green;
            background-color: black;
            color: purple;
            border-radius: 5px;
            outline: none;
        }

        .search-bar button {
            margin-left: 10px;
            padding: 10px 15px;
            font-size: 0.7rem;
            background-color: green;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .search-bar button:hover {
            opacity: 0.9;
        }

        /* <!-- Slider Styles --> */
        #timeFilterButton {
            padding: 10px 15px;
            font-size: 0.7rem;
            background-color: green;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #222;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 60%;
            text-align: center;
            color: white;
        }

        .close {
            float: right;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            color: green;
        }

        .slider {
            -webkit-appearance: none;
            width: 90%;
            height: 12px;
            background: #444;
            outline: none;
            border-radius: 10px;
            margin-top: 20px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            background: green;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.7rem;
        }


        .apply-btn:hover {
            opacity: 0.9;
        }

        /* sroll to top btn */
        .scroll-top-btn {
            position: fixed;  /* Ensure it's fixed to viewport */
            bottom: 4%;
            background-color: rgba(240, 255, 240, 0.552);
            right: 4%;
            border: none;
            border-radius: 5px;
            font-size: 1.3rem;
            cursor: pointer;
            z-index: 999;
            display: none;  /* Hidden by default */

        }

        .scroll-top-btn:hover {
            background-color: rgba(86, 168, 86, 0.798);
            transform: scale(1.1);
        }

        /* Counters container */
        #counters {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
            border: 1px solid #666;
            gap: 15px;
            display: none; /* Single display property */
            flex-direction: row; /* Add this to specify flex layout */
        }

        /* Processed counter */
        #processedCounter {
            color: white;
        }

        /* Matches counter */
        #matchesCounter {
            color: #00ffff;  /* Light blue */
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="title">Loading...</div>  <!-- Placeholder initially -->

        <!-- Search Bar -->
        <div class="search-bar">
            <button id="timeFilterButton">‚è≥</button>
                <input type="text" id="keywordSearch" placeholder="Search keywords">
            <button id="searchButton">üîç</button>
            <button id="sortButton" onclick="toggleSort()">Sort: Newest</button>
        </div>

        <button class="new-notes-button" id="newNotesButton" onclick="showNewNotes()">Show 0 New Notes</button>

        <div class="fetch-status" id="fetchStatus">Searching...</div>
        <button id="scrollToTopBtn" class="scroll-top-btn" onclick="scrollToTop()">‚ñ≤</button>

        <div id="notes">

        </div>
    </div>

    <div class="fullscreen" id="fullscreen">
        <img src="" alt="Full Image" id="fullImage">
    </div>

    <!-- Modal for Time Range Selection -->
    <div id="timeModal" class="modal">
        <div class="modal-content" id="modalContent">
            <span class="close" id="closeModal">&times;</span>
            <h2>Select Time Range</h2>
            <input type="range" min="0" max="4" value="0" step="1" class="slider" id="timeRangeSlider">
            <div class="slider-labels">
                <span>24h</span>
                <span>Week</span>
                <span>Month</span>
                <span>Year</span>
                <span>ü¶ï</span>
            </div>
        </div>
    </div>

    <div id="counters" display="none">
        <div id="processedCounter">P: 0</div>
        <div id="matchesCounter">M: 0</div>
    </div>

    <script>
        const fallbackRelays = [
            'wss://relay.damus.io',
            'wss://nos.lol',
            'wss://relay.snort.social',
            'wss://relay.current.fyi',
            'wss://nostr.mom',
            'wss://brb.io/',
            'wss://freespeech.casa',
            'wss://relay.primal.net',
        ];
        let profileCache = {};  // Store fetched profiles to avoid duplicates

        const keywords = ['']; //default keyword
        // Maintain keywords with their toggle state
        let keywordStates = {}; // e.g., { dog: true, cat: true, potato: true }

        let maxNotes = 100;  // Default value, will adjust dynamically
        let notes = [];
        let fetchedNoteIds = new Set();
        let newNotes = [];
        let timeRange = 0; // Default is "Now"
        let processedCount = 0;
        let matchCount = 0;



        // Convert Unix timestamp to human-readable format
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp * 1000);  // Convert to milliseconds
            return date.toLocaleString();  // Format date to readable format
        }


                // Scroll-to-top button logic
const scrollToTopBtn = document.getElementById('scrollToTopBtn');
const container = document.querySelector('.container');

// Track scroll inside the container
container.addEventListener('scroll', handleScroll);

// Handle scroll visibility within the container
function handleScroll() {
    if (container.scrollTop > 300) {
        scrollToTopBtn.style.display = 'block';
    } else {
        scrollToTopBtn.style.display = 'none';
    }
}

// Smooth scroll to top of the container
function scrollToTop() {
    container.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}

// Observe dynamic content for changes
const notesContainer = document.getElementById('notes');

const observer = new MutationObserver(() => {
    handleScroll();  // Trigger scroll check when content changes
});

// Start observing the notes container for added nodes
observer.observe(notesContainer, { childList: true, subtree: true });




        // Trigger visual feedback when fetching starts
function startFetching() {
    const container = document.querySelector('.container');
    const fetchStatus = document.getElementById('fetchStatus');

    container.classList.remove('success', 'error');
    container.classList.add('fetching');
    fetchStatus.style.display = 'block';  // Show "searching..."
}

        // fix this!!!!
        // Update the title dynamically
        document.querySelector('.title').textContent = `${keywords}`; 


            // Stop fetching - Show success (Green glow)
            function fetchingSuccess() {
                const container = document.querySelector('.container');
                const fetchStatus = document.getElementById('fetchStatus');

                container.classList.remove('fetching', 'error');
                container.classList.add('success');
                fetchStatus.style.display = 'none';  // Hide "searching..."

                // Only hide counters if no matches were found
                if (matchCount === 0) {
                    document.getElementById('counters').style.display = 'none';
                }
            }

            // Stop fetching - Show error (Red glow)
            function fetchingError() {
                const container = document.querySelector('.container');
                const fetchStatus = document.getElementById('fetchStatus');

                container.classList.remove('fetching', 'success');
                container.classList.add('error');
                fetchStatus.style.display = 'none';  // Hide "searching..."
            }



//             // Function to update the title dynamically
// function updateTitleWithKeywords() {
//     const titleElement = document.querySelector('.title');
//     const headTitleElement = document.querySelector('title');  // Select <title> in <head>

//     if (keywords.length > 0) {
//         const formattedKeywords = keywords.map(k => `#${k}`).join(' ');  // Format keywords as hashtags
//         titleElement.textContent = formattedKeywords;  // Update visible title
//         headTitleElement.textContent = `${formattedKeywords} | snofl discovery client`;  // Update <title> in head
//     } else {
//         titleElement.textContent = 'snofl discovery client';  // Default if no keywords
//         headTitleElement.textContent = 'snofl discovery client';
//     }
// }

// Function to update the title dynamically with clickable keywords
function updateTitleWithKeywords() {
    const titleElement = document.querySelector('.title');
    const headTitleElement = document.querySelector('title');  // Select <title> in <head>

    if (keywords.length > 0) {
        const formattedKeywords = keywords
            .map(keyword => {
                const isActive = keywordStates[keyword] ?? true; // Default to active if not set
                const spanClass = isActive ? 'keyword active' : 'keyword toggled';
                return `<span class="${spanClass}" onclick="toggleKeyword('${keyword}')">#${keyword}</span>`;
            })
            .join(' ');  // Format keywords as clickable spans

        titleElement.innerHTML = formattedKeywords;  // Update visible title
        headTitleElement.textContent = `${keywords.join(', ')} | snofl discovery client`;  // Update <title> in head
    } else {
        titleElement.textContent = 'snofl discovery client';  // Default if no keywords
        headTitleElement.textContent = 'snofl discovery client';
    }
}

// Function to toggle keyword state
function toggleKeyword(keyword) {
    keywordStates[keyword] = !keywordStates[keyword];  // Toggle the state
    updateTitleWithKeywords(); // Update styles in the title
    updateNotes(); // Filter results based on active keywords
}

let isInitialFetch = false; // Add this flag to track initial fetch state

        // Trigger fetch when user searches
        function triggerSearch() {
            resetCounters();
            const input = document.getElementById('keywordSearch').value.trim();
            // Full reset logic
            processedCount = 0;
            matchCount = 0;
            document.getElementById('processedCounter').textContent = 'P: 0';
            document.getElementById('matchesCounter').textContent = 'M: 0';
            document.getElementById('counters').style.display = 'none';

            keywords.length = 0;  // Clear the existing array
            keywordStates = {}; // Reset keyword toggle states
            isInitialFetch = true; // Set flag for initial fetch
            // keywords.push(...(input ? input.split(' ') : ['catstr']));  // Push new keywords
            if (input) {
                keywords.push(...input.split(' '));  // Push keywords only if input exists

                // Initialize all keywords as active
                keywords.forEach(keyword => {
                    keywordStates[keyword] = true;
                });

                console.log("Searching for keywords:", keywords);

                // Start fetching feedback
                startFetching();
                updateTitleWithKeywords();  // Update title dynamically

                notes = [];
                fetchedNoteIds.clear();
                newNotes = [];
                updateNotes();
                
                fetchNotes().then(() => {
                fetchingSuccess();  // Success after fetch
                }).catch(() => {
                    fetchingError();  // Error on failure
                });
            } else {
                console.log("Empty input - not fetching.");
            }
        }


        document.getElementById('timeFilterButton').addEventListener('click', openTimeModal);
        document.getElementById('searchButton').addEventListener('click', triggerSearch);


        // Remove interval-based fetching if input is empty
        document.getElementById('keywordSearch').addEventListener('input', (e) => {
            const input = e.target.value.trim();
            if (!input && interval) {
                clearInterval(interval);
                console.log("Stopped fetching due to empty input.");
            }
        });

        // Optional: Resume interval fetching after user input
        document.getElementById('keywordSearch').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                triggerSearch();
                if (!interval) {
                    interval = setInterval(fetchNotes, 3333);  // Resume fetching every 3333 ms
                }
            }
        });

        async function getOnlineRelays() {
            try {
                const response = await fetch('https://api.nostr.watch/v1/online');
                const relays = await response.json();
                console.log('Online relays fetched:', relays);
                // Combine online relays with fallback relays (avoiding duplicates)
                const combinedRelays = [...new Set([...relays, ...fallbackRelays])];
                return combinedRelays;
            } catch (error) {
                console.error('Error fetching online relays:', error);
                console.log("Using fallback relays instead.");
                return fallbackRelays;  // Use fallback if fetch fails
            }
        }

        function getRandomRelays(relays, num) {
            const shuffled = relays.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, num);
        }

        // Fetch profiles only for authors whose notes match keywords
        async function fetchProfilesForNotes(notes) {
            const pubkeysToFetch = notes
                .filter(note => !profileCache[note.pubkey])  // Avoid refetching profiles
                .map(note => note.pubkey);

            if (pubkeysToFetch.length === 0) return;  // No new profiles to fetch

            for (let relay of fallbackRelays) {
                try {
                    const ws = new WebSocket(relay);
                    ws.onopen = () => {
                        console.log(`Fetching profiles from ${relay}`);
                        const filter = {
                            kinds: [0],  // Fetch profiles (kind 0)
                            authors: pubkeysToFetch
                        };
                        ws.send(JSON.stringify(["REQ", "profile_batch", filter]));
                    };

                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[2].kind === 0) {
                            const content = JSON.parse(data[2].content);
                            profileCache[data[2].pubkey] = content;  // Cache the profile
                            console.log(`Profile cached for ${data[2].pubkey}`);
                        }
                    };

                    ws.onclose = () => {
                        console.log(`Profile fetch complete from ${relay}`);
                    };
                    ws.onerror = (error) => {
                    console.error(`WebSocket error on ${relay}:`, error);
                };
                } catch (error) {
                    console.error(`Error fetching batch profiles from ${relay}`, error);
                }
            }
        }

        function truncateNip05(nip05) {
            if (nip05.length > 40) {
                const atIndex = nip05.indexOf('@');
                const domain = nip05.substring(atIndex);
                const truncated = `${nip05.substring(0, 10)}...${domain}`;
                return truncated;
            }
            return nip05;
        }


            // Map time ranges to maxNotes dynamically
    const timeToMaxNotes = {
        // 0: 50000,  // Now - fewer notes
        0: 33333,  // 24h
        1: 66666,  // Week
        2: 111111, // Month
        3: 555555, // Year
        4: 1111111  // All time (ü¶ï)
    };


// Open the modal
function openTimeModal() {
    document.getElementById("timeModal").style.display = "block";
}

// Close the modal
function closeTimeModal() {
    document.getElementById("timeModal").style.display = "none";
}

/// Handle slider changes immediately (remove Apply button)
document.getElementById("timeRangeSlider").addEventListener('input', (e) => {
    timeRange = parseInt(e.target.value);
    maxNotes = timeToMaxNotes[timeRange];
    console.log(`Time range set to: ${getTimeRangeLabel(timeRange)}, maxNotes: ${maxNotes}`);
    
    const input = document.getElementById('keywordSearch').value.trim();
    if (input) {
        console.log("Time range set");
    } else {
        console.log("No input during time range change.");
    }
});

// Close modal when clicking outside or pressing the ‚ùå button
window.addEventListener('click', (e) => {
    const modal = document.getElementById("timeModal");
    const modalContent = document.getElementById("modalContent");

    if (e.target === modal || e.target.id === 'closeModal') {
        closeTimeModal();
    }
});

// Get label for the selected time range
function getTimeRangeLabel(value) {
    const ranges = ["24h", "Week", "Month", "Year", "ü¶ï"];
    return ranges[value];
}

// Calculate 'since' based on slider value
function calculateSinceTime(value) {
    const now = Math.floor(Date.now() / 1000);
    switch (value) {
        // case 0: return now;  // Now
        case 0: return now - (24 * 60 * 60);  // 24 hours
        case 1: return now - (7 * 24 * 60 * 60);  // Week
        case 2: return now - (30 * 24 * 60 * 60);  // Month
        case 3: return now - (365 * 24 * 60 * 60);  // Year
        case 4: return 0;  // All time (ü¶ï)
    }
}
// function calculateSinceTime(value) {
//     return 0;  // Ignore slider and fetch everything
// }


        // Kind 1: Note

        function updateCounters() {
            const counters = document.getElementById('counters');
            document.getElementById('processedCounter').textContent = `P: ${processedCount}`;
            document.getElementById('matchesCounter').textContent = `M: ${matchCount}`;
            
            // Auto-show counters only when processing or matches exist
            if (processedCount > 0 || matchCount > 0) {
                counters.style.display = 'flex';
            }
        }

        function resetCounters() {
            processedCount = 0;
            matchCount = 0;
            updateCounters();
        }

        // Fetch notes from relay and collect pubkeys of authors
        async function fetchNotesFromRelay(relay) {
            return new Promise((resolve) => {
                const ws = new WebSocket(relay);

                ws.onopen = () => {
                    console.log(`Connected to ${relay}`);
                    // Adjust the filter for time range
                    const since = calculateSinceTime(timeRange);
                    const filter = {
                        kinds: [1, 30023],  
                        since: calculateSinceTime(timeRange),
                        limit: maxNotes  
                    };
                    
                    ws.send(JSON.stringify(["REQ", "subscription_id", filter]));
                };

                ws.onmessage = async (event) => {
                    processedCount++;
                    updateCounters();
                    const data = JSON.parse(event.data);
                    console.log("Data received:", event.data);

                    if (data[0] === "EVENT") {
                        const note = data[2];
                        const noteId = note.id;

                    // Match exact keywords using regex
                    if (!fetchedNoteIds.has(noteId)) {
                            const content = note.content.toLowerCase();
                            const matches = keywords.some(keyword => {
                            // Regex to match keywords surrounded by non-alphanumeric characters or at the start
                            const regex = new RegExp(`(^|\\s|#)${keyword}(?=\\s|$)`, 'i');
                            return regex.test(content);
                        });

                            if (matches) {
                                matchCount++;
                                updateCounters();
                                const newNote = {
                                    id: note.id,
                                    content: note.content,
                                    pubkey: note.pubkey,
                                    created_at: note.created_at
                                };

                // Insert into notes array immediately during initial fetch
                if (isInitialFetch) {
                    // Find correct position based on sortOrder
                    let insertIndex = notes.findIndex(n => 
                        sortOrder === 'desc' 
                            ? n.created_at <= newNote.created_at 
                            : n.created_at >= newNote.created_at
                    );
                    if (insertIndex === -1) {
                        notes.push(newNote);
                    } else {
                        notes.splice(insertIndex, 0, newNote);
                    }
                    // Trim excess notes if over limit
                    if (notes.length > maxNotes) notes.pop();
                } else {
                    newNotes.unshift(newNote);
                }

                fetchedNoteIds.add(noteId);
                updateNotes(); // Refresh UI

                // Show success feedback on first note
                if (notes.length === 1) fetchingSuccess();
            }
            // console.log('Exact match note fetched:', newNote);
        }
    }
};


                ws.onclose = async () => {
                    console.log(`Connection closed to ${relay}`);
                    
                    // Fetch profiles for new notes
                    await fetchProfilesForNotes(isInitialFetch ? notes : newNotes);  

                // Handle initial fetch completion
                if (isInitialFetch) {
                    isInitialFetch = false; // Reset flag
                    sortNotes(); // Final sort to ensure correctness
                    updateNotes();
                } else if (newNotes.length > 0) {
                    // Show "new notes" button for subsequent updates
                    const newNotesButton = document.getElementById('newNotesButton');
                    newNotesButton.textContent = `Show ${newNotes.length} More Notes`;
                    newNotesButton.style.display = 'block';
                }

                resolve();
};
                // Close the WebSocket if it stays open too long (timeout)
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        console.warn(`Closing WebSocket due to timeout: ${relay}`);
                        ws.close();
                    }
                }, 60000);  // 60-second timeout for each WebSocket
            });
        }



        let sortOrder = 'desc';  // Default to 'newest first'

        // Toggle the sorting order and re-render notes
        function toggleSort() {
            sortOrder = (sortOrder === 'desc') ? 'asc' : 'desc';
            document.getElementById('sortButton').textContent = `Sort: ${sortOrder === 'desc' ? 'Newest' : 'Oldest'}`;
            sortNotes();
            updateNotes();
        }

        // Sort notes based on timestamp
        function sortNotes() {
            notes.sort((a, b) => {
                if (sortOrder === 'desc') {
                    return b.created_at - a.created_at;  // Newest first
                } else {
                    return a.created_at - b.created_at;  // Oldest first
                }
            });
}

        // Fetch notes from multiple relays in parallel
        async function fetchNotes() {
            const allRelays = await getOnlineRelays();
            // Get 5 random relays + ensure fallback relays are part of it and Using "Set" to ensure relays are unique
            const selectedRelays = [...new Set([...getRandomRelays(allRelays, 10), ...fallbackRelays])];
            const promises = selectedRelays.map(relay => fetchNotesFromRelay(relay));
            
            // Process all relay fetches in parallel
            try {
                await Promise.all(promises);
                console.log(`New notes fetched: ${newNotes.length}`);

                sortNotes();  // Sort new notes before displaying
                updateNotes();  // Update UI

                fetchingSuccess();
            } catch (error) {
                fetchingError();
                console.error('Fetching notes failed:', error);
            }
        }

        let interval;  

        // Helper function to shorten pubkey (e.g., abc1...def9)
        function shortenPubKey(pubkey) {
            if (pubkey.length > 8) {
                return `${pubkey.slice(0, 4)}...${pubkey.slice(-4)}`;
            }
            return pubkey;  // Return full key if it's unusually short
        }

        // 1. Highlight Keywords and URLs
function highlightContent(content) {
    // Highlight https:// links (clickable, dark blue)
    content = content.replace(/https:\/\/\S+/gi, (match) => {
        let highlightedLink = match;
        // Highlight keyword inside the link
        keywords.forEach(keyword => {
            const regex = new RegExp(`(${keyword})`, 'gi');
            highlightedLink = highlightedLink.replace(regex, '<span style="color: blue;">$1</span>');
        });

        return `<a href="${match}" target="_blank" style="color: darkblue; text-decoration: underline;">${highlightedLink}</a>`;
    });

    // Highlight http:// links (non-clickable, grey)
    content = content.replace(/http:\/\/\S+/gi, (match) => {
        let highlightedText = match;
        keywords.forEach(keyword => {
            const regex = new RegExp(`(${keyword})`, 'gi');
            highlightedText = highlightedText.replace(regex, '<span style="color: blue;">$1</span>');
        });

        return `<span style="color: grey;">${highlightedText}</span>`;
    });

    // Highlight hashtags #keyword (green, bold)
    keywords.forEach(keyword => {
        const hashtagRegex = new RegExp(`#(${keyword})\\b`, 'gi');
        content = content.replace(hashtagRegex, '<span class="hashtag">#$1</span>');
    });

    // Highlight regular keywords (not inside links or hashtags) in purple
    keywords.forEach(keyword => {
        const normalRegex = new RegExp(`(?<![/])(?<!https:|http:)\\b(${keyword})\\b`, 'gi');
        content = content.replace(normalRegex, '<span class="highlight">$1</span>');
    });

    return content;
}

        function updateNotes() {
            const notesContainer = document.getElementById('notes');


    // Filter notes based on active keywords
    const activeKeywords = Object.keys(keywordStates).filter(k => keywordStates[k]);
    const filteredNotes = notes.filter(note => {
        const content = note.content.toLowerCase();
        return activeKeywords.some(keyword => content.includes(keyword.toLowerCase()));
    });




            // Render all notes (hide notes with only toggled-off keywords)
            notesContainer.innerHTML = filteredNotes.map(note => {
                    const profile = profileCache[note.pubkey] || {};

                // Generate avatar if profile image is missing
                const avatarUrl = profile.picture 
                    ? profile.picture 
                    : `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${note.pubkey}`;

                // Format timestamp
                const readableTime = formatTimestamp(note.created_at || Date.now() / 1000);

                // // Highlight keywords and hashtags
                // let highlightedContent = note.content;
                
                // keywords.forEach(keyword => {
                //     // Highlight hashtags with full words (e.g., #keyword) in green
                //     const hashtagRegex = new RegExp(`#(${keyword})\\b`, 'gi');
                //     highlightedContent = highlightedContent.replace(hashtagRegex, '<span class="hashtag">#$1</span>');
                    
                //     // Highlight regular keywords not part of hashtags in purple
                //     const normalRegex = new RegExp(`(?<!#)\\b(${keyword})\\b`, 'gi');  // Ignore matches preceded by #
                //     highlightedContent = highlightedContent.replace(normalRegex, '<span class="highlight">$1</span>');
                // });

        // Highlight keywords and hashtags
        let highlightedContent = note.content;

        keywords.forEach(keyword => {
            const isActive = keywordStates[keyword] ?? true; // Check toggle state
            const style = isActive ? 'highlight' : 'inactive';

            // Highlight hashtags with full words (e.g., #keyword) in green
            const hashtagRegex = new RegExp(`#(${keyword})\\b`, 'gi');
            highlightedContent = highlightedContent.replace(
                hashtagRegex,
                `<span class="${isActive ? 'hashtag' : 'inactive'}">#$1</span>`
            );

            // Highlight regular keywords not part of hashtags in purple or inactive gray
            const normalRegex = new RegExp(`(?<!#)\\b(${keyword})\\b`, 'gi'); // Ignore matches preceded by #
            highlightedContent = highlightedContent.replace(
                normalRegex,
                `<span class="${style}">$1</span>`
            );
        });

                // Determine visibility of the note
                const noteContent = note.content.toLowerCase();
        const hasOnlyToggledKeywords = keywords.every(keyword =>
            noteContent.includes(keyword.toLowerCase()) && !keywordStates[keyword]
        );
        const visibilityStyle = hasOnlyToggledKeywords ? 'display: none;' : '';

                return `
                    <div class="note"style="${visibilityStyle}">
                        <button class="copy-button" onclick="copyToClipboard('${note.id}')">
                            <img src="https://img.icons8.com/material-outlined/24/000000/copy.png" alt="Copy Icon">
                        </button>
                        <div class="note-header">
                            <img src="${avatarUrl}" 
                                alt="User Image" 
                                class="profile-img" 
                                data-pubkey="${note.pubkey}"
                                onload="this.classList.add('loaded')"
                                onerror="this.src='${avatarUrl}'; this.classList.add('loaded')">
                            <div>
                                <span>${profile.name || shortenPubKey(note.pubkey)}</span>
                                ${profile.nip05 ? `<div class="nip05">${truncateNip05(profile.nip05)}</div>` : ''}
                            </div>
                        </div>
                        <div class="note-content">
                            ${highlightedContent.replace(/(https?:\/\/\S+\.(?:jpg|jpeg|gif|png|webp))/gi, match => `<img src="${match}" alt="Image">`)}
                        </div>

                    <!-- Icons and timestamp container -->
                    <div class="note-footer">
                        <div class="note-icons">
                            <span class="icon" title="Thumbs Up" onclick="handleIconClick('upvote', '${note.id}')">üëç</span>
                            <span class="icon" title="Thumbs Down" onclick="handleIconClick('downvote', '${note.id}')">üëé</span>
                            <span class="icon" title="Repost" onclick="handleIconClick('repost', '${note.id}')">üîÅ</span>
                            <span class="icon" title="Reply" onclick="handleIconClick('reply', '${note.id}')">üí¨</span>
                        </div>
                        <div class="note-timestamp">
                            ${readableTime}
                        </div>
                    </div>
                </div>
                `;
            }).join('');


            // Attach click event to profile images for redirection
            document.querySelectorAll('.profile-img').forEach(img => {
                img.addEventListener('click', (e) => {
                    const pubkey = e.target.getAttribute('data-pubkey');
                    window.open(`https://nosta.me/${pubkey}`, '_blank');
                });
            });

            // Click to enlarge images inside note content
            const images = document.querySelectorAll('.note-content img');
            images.forEach(img => {
                img.addEventListener('click', () => {
                    const fullScreenContainer = document.getElementById('fullscreen');
                    const fullImage = document.getElementById('fullImage');
                    fullImage.src = img.src;
                    fullScreenContainer.classList.add('active');
                });
            });
        }

        // Show new notes when the button is clicked
        function showNewNotes() {
            notes = [...newNotes, ...notes].slice(0, maxNotes); // Merge and limit
            newNotes = [];  // Clear the new notes array
            sortNotes();
            updateNotes();  // Refresh the note display

            document.getElementById('newNotesButton').style.display = 'none';
            console.log('New notes displayed');
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard ${note.id}');
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        document.getElementById('fullscreen').addEventListener('click', () => {
            const fullScreenContainer = document.getElementById('fullscreen');
            fullScreenContainer.classList.remove('active');
        });

        // Handle icon click actions (for now just logging) It will be a future feature for reposting, replies and reactions.
        function handleIconClick(action, noteId) {
            console.log(`${action} clicked for note: ${noteId}`);
        }

        // The visitor trigers this auto search! 

        // Auto-fetch keywords from URL and trigger search on page load
window.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const keywordsFromURL = urlParams.get('h');

    if (keywordsFromURL) {
        const keywordArray = keywordsFromURL.split(',');

        // Populate the keywords into the search input
        document.getElementById('keywordSearch').value = keywordArray.join(' ');

        // Update keywords array and trigger search immediately
        keywords.length = 0;  // Clear existing keywords
        keywords.push(...keywordArray);

        console.log("Auto-searching for:", keywords);

        // Set max history (full slider)
        timeRange = 5;  // Set slider to 'All Time'
        maxNotes = timeToMaxNotes[timeRange];  // Update max notes based on slider

        // Adjust the slider visually
        document.getElementById('timeRangeSlider').value = 5; // look up for 1 year back

        updateTitleWithKeywords();  // Update the title with keywords
        startFetching();  // Start fetching visual feedback

        // Trigger search automatically
        fetchNotes().then(() => {
            fetchingSuccess();
        }).catch(() => {
            fetchingError();
        });
    }
});

    </script>
</body>
</html>
